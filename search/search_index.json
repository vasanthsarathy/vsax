{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VSAX: Vector Symbolic Algebra for JAX","text":"<p>VSAX is a GPU-accelerated, JAX-native Python library for Vector Symbolic Architectures (VSAs). It provides composable symbolic representations using hypervectors, algebraic operations for binding and bundling, and encoding strategies for symbolic and structured data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\ude80 Three VSA Models: FHRR, MAP, and Binary implementations \u2705</li> <li>\u26a1 GPU-Accelerated: Built on JAX for high-performance computation</li> <li>\ud83e\udde9 Modular Architecture: Clean separation between representations and operations</li> <li>\ud83e\uddec Complete Representations: Complex, Real, and Binary hypervectors \u2705</li> <li>\u2699\ufe0f Full Operation Sets: FFT-based FHRR, MAP, and XOR/majority Binary ops \u2705</li> <li>\ud83c\udfb2 Random Sampling: Sampling utilities for all representation types \u2705</li> <li>\ud83d\udcaf Type-Safe: Full type annotations with mypy support</li> <li>\u2705 Well-Tested: 175 tests with 96% coverage</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#from-pypi-coming-soon","title":"From PyPI (Coming Soon)","text":"<pre><code>pip install vsax\n</code></pre>"},{"location":"#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/yourusername/vsax.git\ncd vsax\n\n# Using uv (recommended)\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv pip install -e \".[dev]\"\n\n# Or using pip\npip install -e \".[dev]\"\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":""},{"location":"#simple-api-v030","title":"Simple API (v0.3.0+)","text":"<pre><code>from vsax import create_fhrr_model, VSAMemory\n\n# Create model with factory function\nmodel = create_fhrr_model(dim=512)\n\n# Create memory for symbols\nmemory = VSAMemory(model)\nmemory.add_many([\"dog\", \"cat\", \"animal\"])\n\n# Access and manipulate symbols\ndog = memory[\"dog\"]\nanimal = memory[\"animal\"]\n\n# Bind two concepts (circular convolution)\ndog_is_animal = model.opset.bind(dog.vec, animal.vec)\n\n# Bundle multiple concepts (sum and normalize)\npets = model.opset.bundle(memory[\"dog\"].vec, memory[\"cat\"].vec)\n</code></pre>"},{"location":"#map-model-real-hypervectors","title":"MAP Model (Real Hypervectors)","text":"<pre><code>from vsax import RealHypervector, MAPOperations, sample_random\n\nmodel = VSAModel(\n    dim=512,\n    rep_cls=RealHypervector,\n    opset=MAPOperations(),\n    sampler=sample_random\n)\n\n# Element-wise multiplication for binding\n# Element-wise mean for bundling\n</code></pre>"},{"location":"#binary-model-bipolar-hypervectors","title":"Binary Model (Bipolar Hypervectors)","text":"<pre><code>from vsax import BinaryHypervector, BinaryOperations, sample_binary_random\n\nmodel = VSAModel(\n    dim=512,\n    rep_cls=BinaryHypervector,\n    opset=BinaryOperations(),\n    sampler=sample_binary_random\n)\n\n# XOR binding (exact unbinding)\n# Majority voting for bundling\n</code></pre>"},{"location":"#development-status","title":"Development Status","text":"<p>Current: Iteration 2 Complete \u2705</p>"},{"location":"#completed","title":"Completed","text":"<p>Iteration 1 (v0.1.0): Foundation &amp; Infrastructure - \u2705 Core abstract classes (AbstractHypervector, AbstractOpSet) - \u2705 VSAModel dataclass - \u2705 Package structure - \u2705 Testing infrastructure (pytest, coverage) - \u2705 CI/CD pipeline (GitHub Actions) - \u2705 Documentation site (MkDocs)</p> <p>Iteration 2 (v0.2.0): Core Algebras - \u2705 All 3 representations (Complex, Real, Binary) - \u2705 All 3 operation sets (FHRR, MAP, Binary) - \u2705 Sampling utilities - \u2705 175 comprehensive tests with 96% coverage - \u2705 Full integration tests</p>"},{"location":"#coming-next","title":"Coming Next","text":"<p>Iteration 3 (v0.3.0): Models &amp; Memory - VSAMemory for symbol storage - Factory functions for easy model creation - Integration utilities</p> <p>Iteration 4 (v0.4.0): First Usable Release - ScalarEncoder and DictEncoder - Complete working examples - Tutorial notebooks</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>User Guide - Detailed guides for all components</li> <li>Examples - Working examples for all three models</li> <li>API Reference - Complete API documentation</li> <li>Design Specification - Technical design details</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see CONTRIBUTING.md for guidelines.</p>"},{"location":"#license","title":"License","text":"<p>VSAX is released under the MIT License. See LICENSE for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use VSAX in your research, please cite:</p> <pre><code>@software{vsax2025,\n  title = {VSAX: Vector Symbolic Algebra for JAX},\n  author = {VSAX Contributors},\n  year = {2025},\n  version = {0.2.0},\n  url = {https://github.com/yourusername/vsax}\n}\n</code></pre>"},{"location":"design-spec/","title":"Technical Specification: VSAX - Vector Symbolic Algebra Library","text":""},{"location":"design-spec/#overview","title":"Overview","text":"<p>VSAX is a GPU-accelerated, JAX-native Python library for vector symbolic architectures (VSAs). It provides composable symbolic representations using hypervectors, algebraic operations for binding and bundling, and encoding strategies for symbolic and structured data. The library is designed to be modular, efficient, and extensible.</p>"},{"location":"design-spec/#core-objectives","title":"Core Objectives","text":"<ul> <li>Enable definition of VSA models combining representations (e.g., complex, real, binary) with algebraic operation sets (e.g., FHRR, MAP).</li> <li>Support encoding of symbolic data (scalars, dictionaries, graphs) using model-defined operations.</li> <li>Maintain a persistent, accessible store of basis hypervectors.</li> <li>Be fully compatible with JAX for high-performance, differentiable, GPU/TPU computation.</li> <li>Provide a clean API and separation of concerns.</li> <li>Be as usable and expressive as NumPy or PyTorch for symbolic computation.</li> </ul>"},{"location":"design-spec/#architecture","title":"Architecture","text":""},{"location":"design-spec/#1-vsamodel","title":"1. VSAModel","text":"<ul> <li><code>dim: int</code> \u2014 dimensionality of all hypervectors</li> <li><code>rep_cls: Type[AbstractHypervector]</code> \u2014 the representation class (e.g. ComplexHypervector)</li> <li><code>opset: AbstractOpSet</code> \u2014 operation strategies (bind, bundle, inverse)</li> <li><code>sampler: Callable[[int, int], jnp.ndarray]</code> \u2014 function for sampling raw vectors</li> </ul> <p>\u27a1\ufe0f Immutable dataclass container for algebra definition. No ops. Used by encoders and memory.</p>"},{"location":"design-spec/#2-vsamemory","title":"2. VSAMemory","text":"<ul> <li>Stores named hypervectors (basis symbols)</li> <li>Uses <code>VSAModel</code> to sample and wrap vectors</li> <li>Supports dictionary-style access:</li> <li><code>memory.add(\"apple\")</code></li> <li><code>memory[\"apple\"]</code></li> <li>Methods:</li> <li><code>add(name: str)</code></li> <li><code>add_many(names: list[str])</code></li> <li><code>get(name: str)</code> \u2192 returns representation-wrapped vector</li> </ul> <p>\u27a1\ufe0f Symbol table + runtime memory for symbolic concepts.</p>"},{"location":"design-spec/#3-abstracthypervector","title":"3. AbstractHypervector","text":"<ul> <li>Base class for representations</li> <li>Wraps a single <code>jnp.ndarray</code> with:</li> <li><code>.vec</code>: the underlying vector</li> <li><code>.normalize()</code></li> <li><code>.to_numpy()</code></li> <li><code>.shape</code>, <code>.dtype</code> proxies</li> <li>Future: implement <code>__jax_array__</code> and <code>__array__</code> for seamless ops</li> </ul> <p>\u27a1\ufe0f Allows clean vector math and JAX compatibility.</p>"},{"location":"design-spec/#4-abstractopset","title":"4. AbstractOpSet","text":"<p>Defines symbolic operations over <code>jnp.ndarray</code>s: - <code>bind(a, b)</code> - <code>bundle(*args)</code> - <code>inverse(a)</code> - <code>permute(a, shift)</code> (optional)</p> <p>\u27a1\ufe0f Stateless, pure functional interface for algebra.</p>"},{"location":"design-spec/#5-encoders","title":"5. Encoders","text":"<p>Classes that convert structured data into hypervectors:</p>"},{"location":"design-spec/#scalarencoder","title":"ScalarEncoder","text":"<ul> <li>Input: <code>name: str</code>, <code>value: float</code></li> <li>Output: powered basis vector (e.g. <code>basis_vec ** value</code>)</li> </ul>"},{"location":"design-spec/#dictencoder","title":"DictEncoder","text":"<ul> <li>Input: <code>{role: filler}</code></li> <li>Output: bundled binding of role-filler pairs</li> </ul> <p>\u27a1\ufe0f Each encoder accepts a model and memory. Add <code>.fit()</code>, <code>.encode()</code> for consistency.</p>"},{"location":"design-spec/#6-similarity-metrics","title":"6. Similarity Metrics","text":"<p>Located in <code>vsax/similarity/</code> - <code>cosine_similarity(a, b)</code> - <code>dot_similarity(a, b)</code> - <code>hamming_similarity(a, b)</code></p> <p>\u27a1\ufe0f Independent of model. Uses <code>.vec</code> or coerces inputs.</p>"},{"location":"design-spec/#7-io","title":"7. I/O","text":""},{"location":"design-spec/#save_basismemory-path","title":"<code>save_basis(memory, path)</code>","text":"<ul> <li>JSON serialization of named basis vectors</li> </ul>"},{"location":"design-spec/#load_basismemory-path","title":"<code>load_basis(memory, path)</code>","text":"<ul> <li>Load into a memory from disk using the model's <code>rep_cls</code></li> </ul> <p>\u27a1\ufe0f Reuse persistent symbolic spaces across sessions.</p>"},{"location":"design-spec/#8-vector-utilities-planned","title":"8. Vector Utilities (Planned)","text":"<ul> <li><code>vsax.utils.coerce_vec()</code> \u2014 ensure input is <code>jnp.ndarray</code></li> <li><code>vsax.utils.vmap_ops()</code> \u2014 batch version of bind/bundle</li> <li><code>vsax.utils.pretty_repr()</code> \u2014 printing shape/type of vectors</li> </ul> <p>\u27a1\ufe0f Improves usability and debugging.</p>"},{"location":"design-spec/#representations","title":"Representations","text":"<p>Located in <code>vsax/representations/</code> - <code>ComplexHypervector</code> \u2014 phase-based encoding, useful for FHRR - <code>BinaryHypervector</code> \u2014 elementwise \u00b11 or 0/1 vectors - <code>RealHypervector</code> \u2014 continuous valued vectors</p> <p>Each wraps a <code>jnp.ndarray</code> and conforms to <code>AbstractHypervector</code>.</p>"},{"location":"design-spec/#operation-sets","title":"Operation Sets","text":"<p>Located in <code>vsax/ops/</code> - <code>FHRROperations</code> \u2014 FFT-based circular convolution - <code>MAPOperations</code> \u2014 elementwise multiplication and mean - <code>BinaryOperations</code> \u2014 XOR, majority</p> <p>\u27a1\ufe0f Functional, stateless ops working directly on <code>jnp.ndarray</code>s.</p>"},{"location":"design-spec/#sampling","title":"Sampling","text":"<p>Located in <code>vsax/sampling/</code> - <code>sample_random(dim, n)</code> \u2014 random normal - <code>sample_circular(dim, n)</code> \u2014 structured circular sampling</p> <p>\u27a1\ufe0f Used by <code>VSAModel</code> for basis vector generation.</p>"},{"location":"design-spec/#test-coverage","title":"Test Coverage","text":"<p>Located in <code>tests/</code> - <code>test_model_memory_init()</code> - <code>test_scalar_encoding()</code> - <code>test_dict_encoding()</code> - <code>test_similarity_metrics()</code> - <code>test_save_load()</code> - <code>test_vector_ops()</code> - <code>test_batch_encoding()</code> (planned)</p> <p>\u27a1\ufe0f Validates representation correctness and symbolic consistency.</p>"},{"location":"design-spec/#usage-examples","title":"Usage Examples","text":""},{"location":"design-spec/#example-1-basic-symbolic-binding","title":"Example 1: Basic symbolic binding","text":"<pre><code>a = memory[\"apple\"]\nb = memory[\"fruit\"]\nencoded = model.opset.bind(a.vec, b.vec)\n</code></pre>"},{"location":"design-spec/#example-2-scalar-encoding","title":"Example 2: Scalar Encoding","text":"<pre><code>encoder = ScalarEncoder(model, memory)\nmemory.add(\"temperature\")\nvec = encoder.encode(\"temperature\", 23.5)\n</code></pre>"},{"location":"design-spec/#example-3-dictionary-encoding-role-filler","title":"Example 3: Dictionary Encoding (role-filler)","text":"<pre><code>encoder = DictEncoder(model, memory)\nmemory.add_many([\"subject\", \"predicate\", \"object\", \"dog\", \"is_a\", \"animal\"])\nvec = encoder.encode({\"subject\": \"dog\", \"predicate\": \"is_a\", \"object\": \"animal\"})\n</code></pre>"},{"location":"design-spec/#example-4-similarity","title":"Example 4: Similarity","text":"<pre><code>similarity = cosine_similarity(vec, memory[\"dog\"])\n</code></pre>"},{"location":"design-spec/#example-5-save-and-load-basis","title":"Example 5: Save and Load Basis","text":"<pre><code>save_basis(memory, \"./basis.json\")\nnew_memory = VSAMemory(model)\nload_basis(new_memory, \"./basis.json\")\n</code></pre>"},{"location":"design-spec/#example-6-batch-operations","title":"Example 6: Batch Operations","text":"<pre><code>from vsax.utils.batch import vmap_bind\nX = jnp.stack([a.vec, b.vec, c.vec])\nY = jnp.stack([x.vec, y.vec, z.vec])\nbatch_result = vmap_bind(model.opset, X, Y)\n</code></pre>"},{"location":"design-spec/#example-7-access-vec-automatically","title":"Example 7: Access .vec automatically","text":"<pre><code># Future sugar\nbind(a, b)  # Automatically unwraps .vec if needed\n</code></pre>"},{"location":"design-spec/#extensibility-plan","title":"Extensibility Plan","text":"<ul> <li>Add <code>GraphEncoder</code>, <code>SequenceEncoder</code>, <code>TreeEncoder</code></li> <li>Add <code>QuaternionHypervector</code>, <code>FourierHypervector</code></li> <li>Add coercion logic to auto-handle <code>.vec</code></li> <li>Add dictionary-style access to <code>VSAMemory</code></li> <li>Implement <code>__jax_array__</code> on representations for seamless ops</li> <li>Add <code>vmap</code>/<code>jit</code>-friendly versions of bind/bundle</li> <li>Streamlit UI for interactive symbolic exploration</li> <li>CLI tools for inspecting memory</li> <li>Registries for custom representations and opsets</li> </ul>"},{"location":"design-spec/#summary","title":"Summary","text":"<p>VSAX provides a principled, modular, and efficient system for symbolic reasoning with hypervectors. It is built for researchers and developers interested in neurosymbolic AI, cognitive modeling, and high-performance semantic encoding systems.</p> <p>Usability is prioritized with a clean, NumPy-style API, automatic coercion, batch operations, and JAX-native performance \u2014 enabling symbolic algebra at scale.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>VSAX requires Python 3.9 or later.</p>"},{"location":"getting-started/#from-pypi-coming-soon","title":"From PyPI (Coming Soon)","text":"<pre><code>pip install vsax\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":""},{"location":"getting-started/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>uv is a fast Python package installer and resolver created by Astral (the makers of ruff). It's significantly faster than pip and handles virtual environments seamlessly.</p> <p>Install uv:</p> <pre><code># Unix/macOS\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Install VSAX:</p> <pre><code>git clone https://github.com/yourusername/vsax.git\ncd vsax\n\n# Create virtual environment and install\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv pip install -e .\n</code></pre>"},{"location":"getting-started/#using-pip","title":"Using pip","text":"<pre><code>git clone https://github.com/yourusername/vsax.git\ncd vsax\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install package\npip install -e .\n</code></pre>"},{"location":"getting-started/#development-installation","title":"Development Installation","text":"<p>To install with development dependencies:</p> <p>Using uv: <pre><code>uv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv pip install -e \".[dev,docs]\"\n</code></pre></p> <p>Using pip: <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -e \".[dev,docs]\"\n</code></pre></p>"},{"location":"getting-started/#verifying-installation","title":"Verifying Installation","text":"<pre><code># Check that vsax is installed\npython -c \"import vsax; print(vsax.__version__)\"\n\n# Run tests\npytest\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Coming in Iteration 2+</p> <p>The library will support three VSA models:</p> <ol> <li>FHRR - Fourier Holographic Reduced Representation</li> <li>MAP - Multiply-Add-Permute</li> <li>Binary VSA - Binary hypervectors with XOR binding</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference</li> <li>Check out example notebooks (coming in Iteration 4)</li> <li>Read the design specification</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for VSAX v0.2.0.</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>Base Classes - Abstract interfaces (AbstractHypervector, AbstractOpSet)</li> <li>VSAModel - Immutable model container</li> </ul>"},{"location":"api/#representations","title":"Representations","text":"<ul> <li>ComplexHypervector - Complex-valued phase-based representation</li> <li>RealHypervector - Real-valued continuous representation</li> <li>BinaryHypervector - Binary/bipolar discrete representation</li> </ul>"},{"location":"api/#operations","title":"Operations","text":"<ul> <li>FHRROperations - FFT-based circular convolution</li> <li>MAPOperations - Element-wise multiply and mean</li> <li>BinaryOperations - XOR and majority voting</li> </ul>"},{"location":"api/#sampling","title":"Sampling","text":"<ul> <li>Sampling Functions - Random vector generation</li> </ul>"},{"location":"api/#coming-soon","title":"Coming Soon","text":"<ul> <li>Encoders (Iteration 4) - ScalarEncoder, DictEncoder</li> <li>Similarity (Iteration 5) - Cosine, dot, Hamming similarity</li> <li>I/O (Iteration 6) - Save and load basis vectors</li> </ul>"},{"location":"api/#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started</li> <li>User Guide</li> <li>Examples</li> </ul>"},{"location":"api/sampling/","title":"Sampling Functions","text":"<p>Functions for generating random basis hypervectors.</p>"},{"location":"api/sampling/#sample_random","title":"sample_random","text":""},{"location":"api/sampling/#vsax.sampling.sample_random","title":"<code>vsax.sampling.sample_random(dim, n, key=None)</code>","text":"<p>Sample n random real-valued vectors from normal distribution.</p> <p>Generates random vectors with elements drawn from a standard normal distribution N(0, 1). These are suitable for use with MAP operations.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of each vector.</p> required <code>n</code> <code>int</code> <p>Number of vectors to sample.</p> required <code>key</code> <code>Optional[PRNGKey]</code> <p>JAX random key. If None, uses PRNGKey(0).</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>JAX array of shape (n, dim) containing sampled vectors.</p> Example <p>import jax key = jax.random.PRNGKey(42) vectors = sample_random(512, 10, key) assert vectors.shape == (10, 512) assert not jnp.iscomplexobj(vectors)</p> Source code in <code>vsax/sampling/random.py</code> <pre><code>def sample_random(\n    dim: int, n: int, key: Optional[jax.random.PRNGKey] = None\n) -&gt; jnp.ndarray:\n    \"\"\"Sample n random real-valued vectors from normal distribution.\n\n    Generates random vectors with elements drawn from a standard normal\n    distribution N(0, 1). These are suitable for use with MAP operations.\n\n    Args:\n        dim: Dimensionality of each vector.\n        n: Number of vectors to sample.\n        key: JAX random key. If None, uses PRNGKey(0).\n\n    Returns:\n        JAX array of shape (n, dim) containing sampled vectors.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; key = jax.random.PRNGKey(42)\n        &gt;&gt;&gt; vectors = sample_random(512, 10, key)\n        &gt;&gt;&gt; assert vectors.shape == (10, 512)\n        &gt;&gt;&gt; assert not jnp.iscomplexobj(vectors)\n    \"\"\"\n    if key is None:\n        key = jax.random.PRNGKey(0)\n\n    return jax.random.normal(key, shape=(n, dim))\n</code></pre>"},{"location":"api/sampling/#sample_complex_random","title":"sample_complex_random","text":""},{"location":"api/sampling/#vsax.sampling.sample_complex_random","title":"<code>vsax.sampling.sample_complex_random(dim, n, key=None)</code>","text":"<p>Sample n random complex-valued vectors with random phases.</p> <p>Generates unit-magnitude complex vectors with uniformly random phases in [0, 2\u03c0). These are suitable for use with FHRR operations.</p> <p>The vectors have the form: exp(i * \u03b8) where \u03b8 ~ Uniform(0, 2\u03c0).</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of each vector.</p> required <code>n</code> <code>int</code> <p>Number of vectors to sample.</p> required <code>key</code> <code>Optional[PRNGKey]</code> <p>JAX random key. If None, uses PRNGKey(0).</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>JAX array of shape (n, dim) containing complex unit-magnitude vectors.</p> Example <p>import jax key = jax.random.PRNGKey(42) vectors = sample_complex_random(512, 10, key) assert vectors.shape == (10, 512) assert jnp.iscomplexobj(vectors)</p> Source code in <code>vsax/sampling/random.py</code> <pre><code>def sample_complex_random(\n    dim: int, n: int, key: Optional[jax.random.PRNGKey] = None\n) -&gt; jnp.ndarray:\n    \"\"\"Sample n random complex-valued vectors with random phases.\n\n    Generates unit-magnitude complex vectors with uniformly random phases\n    in [0, 2\u03c0). These are suitable for use with FHRR operations.\n\n    The vectors have the form: exp(i * \u03b8) where \u03b8 ~ Uniform(0, 2\u03c0).\n\n    Args:\n        dim: Dimensionality of each vector.\n        n: Number of vectors to sample.\n        key: JAX random key. If None, uses PRNGKey(0).\n\n    Returns:\n        JAX array of shape (n, dim) containing complex unit-magnitude vectors.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; key = jax.random.PRNGKey(42)\n        &gt;&gt;&gt; vectors = sample_complex_random(512, 10, key)\n        &gt;&gt;&gt; assert vectors.shape == (10, 512)\n        &gt;&gt;&gt; assert jnp.iscomplexobj(vectors)\n        &gt;&gt;&gt; # All magnitudes should be 1.0\n        &gt;&gt;&gt; assert jnp.allclose(jnp.abs(vectors), 1.0)\n    \"\"\"\n    if key is None:\n        key = jax.random.PRNGKey(0)\n\n    # Sample random phases uniformly in [0, 2\u03c0)\n    phases = jax.random.uniform(key, shape=(n, dim), minval=0, maxval=2 * jnp.pi)\n\n    # Convert to complex unit vectors\n    return jnp.exp(1j * phases)\n</code></pre>"},{"location":"api/sampling/#vsax.sampling.sample_complex_random--all-magnitudes-should-be-10","title":"All magnitudes should be 1.0","text":"<p>assert jnp.allclose(jnp.abs(vectors), 1.0)</p>"},{"location":"api/sampling/#sample_binary_random","title":"sample_binary_random","text":""},{"location":"api/sampling/#vsax.sampling.sample_binary_random","title":"<code>vsax.sampling.sample_binary_random(dim, n, key=None, bipolar=True)</code>","text":"<p>Sample n random binary vectors.</p> <p>Generates random binary vectors with values uniformly sampled from: - Bipolar mode: {-1, +1} - Binary mode: {0, 1}</p> <p>These are suitable for use with Binary VSA operations.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of each vector.</p> required <code>n</code> <code>int</code> <p>Number of vectors to sample.</p> required <code>key</code> <code>Optional[PRNGKey]</code> <p>JAX random key. If None, uses PRNGKey(0).</p> <code>None</code> <code>bipolar</code> <code>bool</code> <p>If True, sample from {-1, +1}. If False, sample from {0, 1}.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>JAX array of shape (n, dim) containing binary values.</p> Example <p>import jax key = jax.random.PRNGKey(42)</p> Source code in <code>vsax/sampling/random.py</code> <pre><code>def sample_binary_random(\n    dim: int, n: int, key: Optional[jax.random.PRNGKey] = None, bipolar: bool = True\n) -&gt; jnp.ndarray:\n    \"\"\"Sample n random binary vectors.\n\n    Generates random binary vectors with values uniformly sampled from:\n    - Bipolar mode: {-1, +1}\n    - Binary mode: {0, 1}\n\n    These are suitable for use with Binary VSA operations.\n\n    Args:\n        dim: Dimensionality of each vector.\n        n: Number of vectors to sample.\n        key: JAX random key. If None, uses PRNGKey(0).\n        bipolar: If True, sample from {-1, +1}. If False, sample from {0, 1}.\n\n    Returns:\n        JAX array of shape (n, dim) containing binary values.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; key = jax.random.PRNGKey(42)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Bipolar sampling\n        &gt;&gt;&gt; bipolar_vecs = sample_binary_random(512, 10, key, bipolar=True)\n        &gt;&gt;&gt; assert bipolar_vecs.shape == (10, 512)\n        &gt;&gt;&gt; assert jnp.all(jnp.isin(bipolar_vecs, jnp.array([-1, 1])))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Binary sampling\n        &gt;&gt;&gt; binary_vecs = sample_binary_random(512, 10, key, bipolar=False)\n        &gt;&gt;&gt; assert jnp.all(jnp.isin(binary_vecs, jnp.array([0, 1])))\n    \"\"\"\n    if key is None:\n        key = jax.random.PRNGKey(0)\n\n    if bipolar:\n        # Sample from {-1, +1}\n        return jax.random.choice(key, jnp.array([-1, 1]), shape=(n, dim))\n    else:\n        # Sample from {0, 1}\n        return jax.random.choice(key, jnp.array([0, 1]), shape=(n, dim))\n</code></pre>"},{"location":"api/sampling/#vsax.sampling.sample_binary_random--bipolar-sampling","title":"Bipolar sampling","text":"<p>bipolar_vecs = sample_binary_random(512, 10, key, bipolar=True) assert bipolar_vecs.shape == (10, 512) assert jnp.all(jnp.isin(bipolar_vecs, jnp.array([-1, 1])))</p>"},{"location":"api/sampling/#vsax.sampling.sample_binary_random--binary-sampling","title":"Binary sampling","text":"<p>binary_vecs = sample_binary_random(512, 10, key, bipolar=False) assert jnp.all(jnp.isin(binary_vecs, jnp.array([0, 1])))</p>"},{"location":"api/core/base/","title":"Base Classes","text":"<p>Core abstract classes that define the VSA interface.</p>"},{"location":"api/core/base/#abstracthypervector","title":"AbstractHypervector","text":""},{"location":"api/core/base/#vsax.core.base.AbstractHypervector","title":"<code>vsax.core.base.AbstractHypervector</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all hypervector representations.</p> <p>Wraps a JAX array and provides common operations for hypervectors. All concrete implementations must inherit from this class.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>The underlying JAX array representing the hypervector.</p> required Source code in <code>vsax/core/base.py</code> <pre><code>class AbstractHypervector(ABC):\n    \"\"\"Base class for all hypervector representations.\n\n    Wraps a JAX array and provides common operations for hypervectors.\n    All concrete implementations must inherit from this class.\n\n    Args:\n        vec: The underlying JAX array representing the hypervector.\n    \"\"\"\n\n    def __init__(self, vec: jnp.ndarray) -&gt; None:\n        \"\"\"Initialize hypervector with underlying array.\n\n        Args:\n            vec: JAX array representing the hypervector.\n        \"\"\"\n        self._vec = vec\n\n    @property\n    def vec(self) -&gt; jnp.ndarray:\n        \"\"\"Return the underlying JAX array.\n\n        Returns:\n            The JAX array wrapped by this hypervector.\n        \"\"\"\n        return self._vec\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Return the shape of the hypervector.\n\n        Returns:\n            Tuple representing the shape of the underlying array.\n        \"\"\"\n        return cast(tuple[int, ...], self._vec.shape)\n\n    @property\n    def dtype(self) -&gt; jnp.dtype:\n        \"\"\"Return the data type of the hypervector.\n\n        Returns:\n            JAX dtype of the underlying array.\n        \"\"\"\n        return self._vec.dtype\n\n    @abstractmethod\n    def normalize(self) -&gt; \"AbstractHypervector\":\n        \"\"\"Normalize the hypervector.\n\n        The normalization method depends on the representation type.\n        For example, complex vectors normalize to unit magnitude (phase-only),\n        while real vectors use L2 normalization.\n\n        Returns:\n            Normalized hypervector of the same type.\n        \"\"\"\n        pass\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"Convert the hypervector to a NumPy array.\n\n        Returns:\n            NumPy array representation of the hypervector.\n        \"\"\"\n        return np.array(self._vec)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the hypervector.\n\n        Returns:\n            String showing class name, shape, and dtype.\n        \"\"\"\n        return f\"{self.__class__.__name__}(shape={self.shape}, dtype={self.dtype})\"\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractHypervector-attributes","title":"Attributes","text":""},{"location":"api/core/base/#vsax.core.base.AbstractHypervector.vec","title":"<code>vec</code>  <code>property</code>","text":"<p>Return the underlying JAX array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The JAX array wrapped by this hypervector.</p>"},{"location":"api/core/base/#vsax.core.base.AbstractHypervector.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the shape of the hypervector.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>Tuple representing the shape of the underlying array.</p>"},{"location":"api/core/base/#vsax.core.base.AbstractHypervector.dtype","title":"<code>dtype</code>  <code>property</code>","text":"<p>Return the data type of the hypervector.</p> <p>Returns:</p> Type Description <code>dtype</code> <p>JAX dtype of the underlying array.</p>"},{"location":"api/core/base/#vsax.core.base.AbstractHypervector-functions","title":"Functions","text":""},{"location":"api/core/base/#vsax.core.base.AbstractHypervector.normalize","title":"<code>normalize()</code>  <code>abstractmethod</code>","text":"<p>Normalize the hypervector.</p> <p>The normalization method depends on the representation type. For example, complex vectors normalize to unit magnitude (phase-only), while real vectors use L2 normalization.</p> <p>Returns:</p> Type Description <code>AbstractHypervector</code> <p>Normalized hypervector of the same type.</p> Source code in <code>vsax/core/base.py</code> <pre><code>@abstractmethod\ndef normalize(self) -&gt; \"AbstractHypervector\":\n    \"\"\"Normalize the hypervector.\n\n    The normalization method depends on the representation type.\n    For example, complex vectors normalize to unit magnitude (phase-only),\n    while real vectors use L2 normalization.\n\n    Returns:\n        Normalized hypervector of the same type.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractHypervector.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert the hypervector to a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>NumPy array representation of the hypervector.</p> Source code in <code>vsax/core/base.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"Convert the hypervector to a NumPy array.\n\n    Returns:\n        NumPy array representation of the hypervector.\n    \"\"\"\n    return np.array(self._vec)\n</code></pre>"},{"location":"api/core/base/#abstractopset","title":"AbstractOpSet","text":""},{"location":"api/core/base/#vsax.core.base.AbstractOpSet","title":"<code>vsax.core.base.AbstractOpSet</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for VSA operation sets.</p> <p>Defines the symbolic algebra operations for binding and bundling hypervectors. All operations work directly on JAX arrays, not on AbstractHypervector instances.</p> <p>Concrete implementations (FHRR, MAP, Binary) must implement all abstract methods.</p> Source code in <code>vsax/core/base.py</code> <pre><code>class AbstractOpSet(ABC):\n    \"\"\"Base class for VSA operation sets.\n\n    Defines the symbolic algebra operations for binding and bundling hypervectors.\n    All operations work directly on JAX arrays, not on AbstractHypervector instances.\n\n    Concrete implementations (FHRR, MAP, Binary) must implement all abstract methods.\n    \"\"\"\n\n    @abstractmethod\n    def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bind two hypervectors together.\n\n        Binding creates a composite representation that is dissimilar to both inputs\n        but can be unbound using the inverse operation. The specific binding operation\n        depends on the algebra (e.g., circular convolution for FHRR, elementwise\n        multiplication for MAP).\n\n        Args:\n            a: First hypervector as JAX array.\n            b: Second hypervector as JAX array.\n\n        Returns:\n            Bound hypervector as JAX array.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bundle multiple hypervectors into a single representation.\n\n        Bundling creates a superposition that is similar to all inputs.\n        The bundled vector can be queried to retrieve the constituent vectors.\n\n        Args:\n            *vecs: Variable number of hypervectors as JAX arrays.\n\n        Returns:\n            Bundled hypervector as JAX array.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Compute the inverse of a hypervector.\n\n        The inverse is used to unbind: if c = bind(a, b), then\n        unbind(c, b) = bind(c, inverse(b)) \u2248 a.\n\n        Args:\n            a: Hypervector as JAX array.\n\n        Returns:\n            Inverse hypervector as JAX array.\n        \"\"\"\n        pass\n\n    def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n        \"\"\"Permute a hypervector by circular shift.\n\n        This is an optional operation. The default implementation performs\n        a circular shift, but concrete classes may override with different\n        permutation strategies.\n\n        Args:\n            a: Hypervector as JAX array.\n            shift: Number of positions to shift (positive = right, negative = left).\n\n        Returns:\n            Permuted hypervector as JAX array.\n        \"\"\"\n        return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractOpSet-functions","title":"Functions","text":""},{"location":"api/core/base/#vsax.core.base.AbstractOpSet.bind","title":"<code>bind(a, b)</code>  <code>abstractmethod</code>","text":"<p>Bind two hypervectors together.</p> <p>Binding creates a composite representation that is dissimilar to both inputs but can be unbound using the inverse operation. The specific binding operation depends on the algebra (e.g., circular convolution for FHRR, elementwise multiplication for MAP).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>First hypervector as JAX array.</p> required <code>b</code> <code>ndarray</code> <p>Second hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Bound hypervector as JAX array.</p> Source code in <code>vsax/core/base.py</code> <pre><code>@abstractmethod\ndef bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bind two hypervectors together.\n\n    Binding creates a composite representation that is dissimilar to both inputs\n    but can be unbound using the inverse operation. The specific binding operation\n    depends on the algebra (e.g., circular convolution for FHRR, elementwise\n    multiplication for MAP).\n\n    Args:\n        a: First hypervector as JAX array.\n        b: Second hypervector as JAX array.\n\n    Returns:\n        Bound hypervector as JAX array.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractOpSet.bundle","title":"<code>bundle(*vecs)</code>  <code>abstractmethod</code>","text":"<p>Bundle multiple hypervectors into a single representation.</p> <p>Bundling creates a superposition that is similar to all inputs. The bundled vector can be queried to retrieve the constituent vectors.</p> <p>Parameters:</p> Name Type Description Default <code>*vecs</code> <code>ndarray</code> <p>Variable number of hypervectors as JAX arrays.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Bundled hypervector as JAX array.</p> Source code in <code>vsax/core/base.py</code> <pre><code>@abstractmethod\ndef bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bundle multiple hypervectors into a single representation.\n\n    Bundling creates a superposition that is similar to all inputs.\n    The bundled vector can be queried to retrieve the constituent vectors.\n\n    Args:\n        *vecs: Variable number of hypervectors as JAX arrays.\n\n    Returns:\n        Bundled hypervector as JAX array.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractOpSet.inverse","title":"<code>inverse(a)</code>  <code>abstractmethod</code>","text":"<p>Compute the inverse of a hypervector.</p> <p>The inverse is used to unbind: if c = bind(a, b), then unbind(c, b) = bind(c, inverse(b)) \u2248 a.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Inverse hypervector as JAX array.</p> Source code in <code>vsax/core/base.py</code> <pre><code>@abstractmethod\ndef inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Compute the inverse of a hypervector.\n\n    The inverse is used to unbind: if c = bind(a, b), then\n    unbind(c, b) = bind(c, inverse(b)) \u2248 a.\n\n    Args:\n        a: Hypervector as JAX array.\n\n    Returns:\n        Inverse hypervector as JAX array.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/base/#vsax.core.base.AbstractOpSet.permute","title":"<code>permute(a, shift)</code>","text":"<p>Permute a hypervector by circular shift.</p> <p>This is an optional operation. The default implementation performs a circular shift, but concrete classes may override with different permutation strategies.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <code>shift</code> <code>int</code> <p>Number of positions to shift (positive = right, negative = left).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permuted hypervector as JAX array.</p> Source code in <code>vsax/core/base.py</code> <pre><code>def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n    \"\"\"Permute a hypervector by circular shift.\n\n    This is an optional operation. The default implementation performs\n    a circular shift, but concrete classes may override with different\n    permutation strategies.\n\n    Args:\n        a: Hypervector as JAX array.\n        shift: Number of positions to shift (positive = right, negative = left).\n\n    Returns:\n        Permuted hypervector as JAX array.\n    \"\"\"\n    return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/core/factory/","title":"Factory Functions","text":"<p>Convenient factory functions for creating VSA models with sensible defaults.</p> <p>These functions provide a simple, one-line way to create fully configured VSA models for each of the three supported algebras: FHRR, MAP, and Binary.</p>"},{"location":"api/core/factory/#create_fhrr_model","title":"create_fhrr_model","text":""},{"location":"api/core/factory/#vsax.core.factory.create_fhrr_model","title":"<code>vsax.core.factory.create_fhrr_model(dim=512, key=None)</code>","text":"<p>Create a FHRR model (Complex hypervectors with FFT-based operations).</p> <p>FHRR (Fourier Holographic Reduced Representation) uses complex-valued hypervectors with circular convolution for binding. It provides exact unbinding via complex conjugation.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of hypervectors. Default: 512.</p> <code>512</code> <code>key</code> <code>Optional[Array]</code> <p>Optional JAX PRNG key for reproducible sampling. Not used in model creation but can be passed to VSAMemory.</p> <code>None</code> <p>Returns:</p> Type Description <code>VSAModel</code> <p>VSAModel configured for FHRR operations.</p> Example <p>from vsax import create_fhrr_model, VSAMemory model = create_fhrr_model(dim=512) memory = VSAMemory(model) memory.add(\"symbol\")</p> Source code in <code>vsax/core/factory.py</code> <pre><code>def create_fhrr_model(dim: int = 512, key: Optional[jax.Array] = None) -&gt; VSAModel:\n    \"\"\"Create a FHRR model (Complex hypervectors with FFT-based operations).\n\n    FHRR (Fourier Holographic Reduced Representation) uses complex-valued\n    hypervectors with circular convolution for binding. It provides exact\n    unbinding via complex conjugation.\n\n    Args:\n        dim: Dimensionality of hypervectors. Default: 512.\n        key: Optional JAX PRNG key for reproducible sampling. Not used in\n            model creation but can be passed to VSAMemory.\n\n    Returns:\n        VSAModel configured for FHRR operations.\n\n    Example:\n        &gt;&gt;&gt; from vsax import create_fhrr_model, VSAMemory\n        &gt;&gt;&gt; model = create_fhrr_model(dim=512)\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"symbol\")\n    \"\"\"\n    return VSAModel(\n        dim=dim,\n        rep_cls=ComplexHypervector,\n        opset=FHRROperations(),\n        sampler=sample_complex_random,\n    )\n</code></pre>"},{"location":"api/core/factory/#create_map_model","title":"create_map_model","text":""},{"location":"api/core/factory/#vsax.core.factory.create_map_model","title":"<code>vsax.core.factory.create_map_model(dim=512, key=None)</code>","text":"<p>Create a MAP model (Real hypervectors with element-wise operations).</p> <p>MAP (Multiply-Add-Permute) uses real-valued hypervectors with element-wise multiplication for binding and averaging for bundling. It provides approximate unbinding.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of hypervectors. Default: 512.</p> <code>512</code> <code>key</code> <code>Optional[Array]</code> <p>Optional JAX PRNG key for reproducible sampling. Not used in model creation but can be passed to VSAMemory.</p> <code>None</code> <p>Returns:</p> Type Description <code>VSAModel</code> <p>VSAModel configured for MAP operations.</p> Example <p>from vsax import create_map_model, VSAMemory model = create_map_model(dim=1024) memory = VSAMemory(model) memory.add_many([\"red\", \"green\", \"blue\"])</p> Source code in <code>vsax/core/factory.py</code> <pre><code>def create_map_model(dim: int = 512, key: Optional[jax.Array] = None) -&gt; VSAModel:\n    \"\"\"Create a MAP model (Real hypervectors with element-wise operations).\n\n    MAP (Multiply-Add-Permute) uses real-valued hypervectors with\n    element-wise multiplication for binding and averaging for bundling.\n    It provides approximate unbinding.\n\n    Args:\n        dim: Dimensionality of hypervectors. Default: 512.\n        key: Optional JAX PRNG key for reproducible sampling. Not used in\n            model creation but can be passed to VSAMemory.\n\n    Returns:\n        VSAModel configured for MAP operations.\n\n    Example:\n        &gt;&gt;&gt; from vsax import create_map_model, VSAMemory\n        &gt;&gt;&gt; model = create_map_model(dim=1024)\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add_many([\"red\", \"green\", \"blue\"])\n    \"\"\"\n    return VSAModel(\n        dim=dim,\n        rep_cls=RealHypervector,\n        opset=MAPOperations(),\n        sampler=sample_random,\n    )\n</code></pre>"},{"location":"api/core/factory/#create_binary_model","title":"create_binary_model","text":""},{"location":"api/core/factory/#vsax.core.factory.create_binary_model","title":"<code>vsax.core.factory.create_binary_model(dim=10000, bipolar=True, key=None)</code>","text":"<p>Create a Binary model (Binary hypervectors with XOR/majority operations).</p> <p>Binary VSA uses discrete {-1, +1} (bipolar) or {0, 1} (binary) hypervectors with XOR for binding and majority voting for bundling. It provides exact unbinding (self-inverse property).</p> <p>Note: Binary models typically require higher dimensionality (10000+) for good performance due to discrete representation.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimensionality of hypervectors. Default: 10000 (higher than continuous models due to discrete representation).</p> <code>10000</code> <code>bipolar</code> <code>bool</code> <p>If True, use {-1, +1} representation. If False, use {0, 1}. Default: True (bipolar is more common).</p> <code>True</code> <code>key</code> <code>Optional[Array]</code> <p>Optional JAX PRNG key for reproducible sampling. Not used in model creation but can be passed to VSAMemory.</p> <code>None</code> <p>Returns:</p> Type Description <code>VSAModel</code> <p>VSAModel configured for Binary operations.</p> Example <p>from vsax import create_binary_model, VSAMemory model = create_binary_model(dim=10000, bipolar=True) memory = VSAMemory(model) memory.add(\"concept\")</p> Source code in <code>vsax/core/factory.py</code> <pre><code>def create_binary_model(\n    dim: int = 10000, bipolar: bool = True, key: Optional[jax.Array] = None\n) -&gt; VSAModel:\n    \"\"\"Create a Binary model (Binary hypervectors with XOR/majority operations).\n\n    Binary VSA uses discrete {-1, +1} (bipolar) or {0, 1} (binary) hypervectors\n    with XOR for binding and majority voting for bundling. It provides exact\n    unbinding (self-inverse property).\n\n    Note: Binary models typically require higher dimensionality (10000+) for\n    good performance due to discrete representation.\n\n    Args:\n        dim: Dimensionality of hypervectors. Default: 10000 (higher than\n            continuous models due to discrete representation).\n        bipolar: If True, use {-1, +1} representation. If False, use {0, 1}.\n            Default: True (bipolar is more common).\n        key: Optional JAX PRNG key for reproducible sampling. Not used in\n            model creation but can be passed to VSAMemory.\n\n    Returns:\n        VSAModel configured for Binary operations.\n\n    Example:\n        &gt;&gt;&gt; from vsax import create_binary_model, VSAMemory\n        &gt;&gt;&gt; model = create_binary_model(dim=10000, bipolar=True)\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"concept\")\n    \"\"\"\n\n    # Create a wrapper sampler that passes bipolar parameter\n    def binary_sampler(dim: int, n: int, key: jax.Array) -&gt; jax.Array:\n        \"\"\"Wrapper sampler that includes bipolar parameter.\"\"\"\n        return sample_binary_random(dim=dim, n=n, key=key, bipolar=bipolar)\n\n    return VSAModel(\n        dim=dim,\n        rep_cls=BinaryHypervector,\n        opset=BinaryOperations(),\n        sampler=binary_sampler,\n    )\n</code></pre>"},{"location":"api/core/memory/","title":"VSAMemory","text":"<p>Dictionary-style symbol table for managing named hypervectors.</p> <p>VSAMemory provides a convenient interface for creating, storing, and accessing hypervectors associated with symbolic names. It automatically handles vector sampling and wrapping using the model's configuration.</p>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory","title":"<code>vsax.core.memory.VSAMemory</code>","text":"<p>Symbol table for storing and managing named basis vectors.</p> <p>VSAMemory provides a dictionary-style interface for creating, storing, and retrieving named hypervectors. Each symbol is associated with a randomly sampled hypervector from the model's sampling distribution.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VSAModel</code> <p>VSAModel instance defining the representation and operations.</p> required <code>key</code> <code>Optional[Array]</code> <p>Optional JAX PRNG key for reproducible sampling. If None, uses a default key.</p> <code>None</code> Example <p>from vsax import create_fhrr_model, VSAMemory model = create_fhrr_model(dim=512) memory = VSAMemory(model) memory.add(\"dog\") memory.add_many([\"cat\", \"bird\"]) dog = memory[\"dog\"] assert \"cat\" in memory print(memory.keys()) ['dog', 'cat', 'bird']</p> Source code in <code>vsax/core/memory.py</code> <pre><code>class VSAMemory:\n    \"\"\"Symbol table for storing and managing named basis vectors.\n\n    VSAMemory provides a dictionary-style interface for creating, storing, and\n    retrieving named hypervectors. Each symbol is associated with a randomly\n    sampled hypervector from the model's sampling distribution.\n\n    Args:\n        model: VSAModel instance defining the representation and operations.\n        key: Optional JAX PRNG key for reproducible sampling. If None, uses a\n            default key.\n\n    Example:\n        &gt;&gt;&gt; from vsax import create_fhrr_model, VSAMemory\n        &gt;&gt;&gt; model = create_fhrr_model(dim=512)\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"dog\")\n        &gt;&gt;&gt; memory.add_many([\"cat\", \"bird\"])\n        &gt;&gt;&gt; dog = memory[\"dog\"]\n        &gt;&gt;&gt; assert \"cat\" in memory\n        &gt;&gt;&gt; print(memory.keys())\n        ['dog', 'cat', 'bird']\n    \"\"\"\n\n    def __init__(self, model: VSAModel, key: Optional[jax.Array] = None) -&gt; None:\n        \"\"\"Initialize VSAMemory with a model.\n\n        Args:\n            model: VSAModel instance defining the VSA algebra.\n            key: Optional JAX PRNG key for reproducible sampling.\n        \"\"\"\n        self._model = model\n        self._symbols: dict[str, AbstractHypervector] = {}\n        self._key = key if key is not None else jax.random.PRNGKey(0)\n        self._counter = 0\n\n    @property\n    def model(self) -&gt; VSAModel:\n        \"\"\"Get the underlying VSAModel.\"\"\"\n        return self._model\n\n    def add(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Add a new symbol to memory with a randomly sampled hypervector.\n\n        If the symbol already exists, returns the existing hypervector without\n        resampling.\n\n        Args:\n            name: Name of the symbol to add.\n\n        Returns:\n            The hypervector associated with the symbol.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; dog = memory.add(\"dog\")\n            &gt;&gt;&gt; assert \"dog\" in memory\n        \"\"\"\n        if name in self._symbols:\n            return self._symbols[name]\n\n        # Split key for this sample\n        self._key, subkey = jax.random.split(self._key)\n\n        # Sample a new vector\n        vec = self._model.sampler(self._model.dim, 1, subkey)[0]\n\n        # Wrap in representation\n        hv = self._model.rep_cls(vec)\n\n        # Store and return\n        self._symbols[name] = hv\n        self._counter += 1\n        return hv\n\n    def add_many(self, names: Iterable[str]) -&gt; list[AbstractHypervector]:\n        \"\"\"Add multiple symbols to memory.\n\n        Args:\n            names: Iterable of symbol names to add.\n\n        Returns:\n            List of hypervectors corresponding to the added symbols.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; colors = memory.add_many([\"red\", \"green\", \"blue\"])\n            &gt;&gt;&gt; assert len(colors) == 3\n        \"\"\"\n        return [self.add(name) for name in names]\n\n    def get(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Get a hypervector by name.\n\n        Args:\n            name: Name of the symbol to retrieve.\n\n        Returns:\n            The hypervector associated with the symbol.\n\n        Raises:\n            KeyError: If the symbol does not exist in memory.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add(\"dog\")\n            &gt;&gt;&gt; dog = memory.get(\"dog\")\n        \"\"\"\n        return self._symbols[name]\n\n    def __getitem__(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Get a hypervector by name using dictionary syntax.\n\n        Args:\n            name: Name of the symbol to retrieve.\n\n        Returns:\n            The hypervector associated with the symbol.\n\n        Raises:\n            KeyError: If the symbol does not exist in memory.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add(\"dog\")\n            &gt;&gt;&gt; dog = memory[\"dog\"]\n        \"\"\"\n        return self.get(name)\n\n    def __contains__(self, name: str) -&gt; bool:\n        \"\"\"Check if a symbol exists in memory.\n\n        Args:\n            name: Name of the symbol to check.\n\n        Returns:\n            True if the symbol exists, False otherwise.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add(\"dog\")\n            &gt;&gt;&gt; assert \"dog\" in memory\n            &gt;&gt;&gt; assert \"cat\" not in memory\n        \"\"\"\n        return name in self._symbols\n\n    def keys(self) -&gt; list[str]:\n        \"\"\"Get all symbol names in memory.\n\n        Returns:\n            List of symbol names.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n            &gt;&gt;&gt; assert memory.keys() == [\"a\", \"b\", \"c\"]\n        \"\"\"\n        return list(self._symbols.keys())\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get the number of symbols in memory.\n\n        Returns:\n            Number of stored symbols.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n            &gt;&gt;&gt; assert len(memory) == 3\n        \"\"\"\n        return len(self._symbols)\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all symbols from memory.\n\n        Example:\n            &gt;&gt;&gt; memory = VSAMemory(model)\n            &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n            &gt;&gt;&gt; memory.clear()\n            &gt;&gt;&gt; assert len(memory) == 0\n        \"\"\"\n        self._symbols.clear()\n        self._counter = 0\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of VSAMemory.\"\"\"\n        return f\"VSAMemory(model={self._model.rep_cls.__name__}, symbols={len(self._symbols)})\"\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory-attributes","title":"Attributes","text":""},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.model","title":"<code>model</code>  <code>property</code>","text":"<p>Get the underlying VSAModel.</p>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory-functions","title":"Functions","text":""},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.__init__","title":"<code>__init__(model, key=None)</code>","text":"<p>Initialize VSAMemory with a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VSAModel</code> <p>VSAModel instance defining the VSA algebra.</p> required <code>key</code> <code>Optional[Array]</code> <p>Optional JAX PRNG key for reproducible sampling.</p> <code>None</code> Source code in <code>vsax/core/memory.py</code> <pre><code>def __init__(self, model: VSAModel, key: Optional[jax.Array] = None) -&gt; None:\n    \"\"\"Initialize VSAMemory with a model.\n\n    Args:\n        model: VSAModel instance defining the VSA algebra.\n        key: Optional JAX PRNG key for reproducible sampling.\n    \"\"\"\n    self._model = model\n    self._symbols: dict[str, AbstractHypervector] = {}\n    self._key = key if key is not None else jax.random.PRNGKey(0)\n    self._counter = 0\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.add","title":"<code>add(name)</code>","text":"<p>Add a new symbol to memory with a randomly sampled hypervector.</p> <p>If the symbol already exists, returns the existing hypervector without resampling.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the symbol to add.</p> required <p>Returns:</p> Type Description <code>AbstractHypervector</code> <p>The hypervector associated with the symbol.</p> Example <p>memory = VSAMemory(model) dog = memory.add(\"dog\") assert \"dog\" in memory</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def add(self, name: str) -&gt; AbstractHypervector:\n    \"\"\"Add a new symbol to memory with a randomly sampled hypervector.\n\n    If the symbol already exists, returns the existing hypervector without\n    resampling.\n\n    Args:\n        name: Name of the symbol to add.\n\n    Returns:\n        The hypervector associated with the symbol.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; dog = memory.add(\"dog\")\n        &gt;&gt;&gt; assert \"dog\" in memory\n    \"\"\"\n    if name in self._symbols:\n        return self._symbols[name]\n\n    # Split key for this sample\n    self._key, subkey = jax.random.split(self._key)\n\n    # Sample a new vector\n    vec = self._model.sampler(self._model.dim, 1, subkey)[0]\n\n    # Wrap in representation\n    hv = self._model.rep_cls(vec)\n\n    # Store and return\n    self._symbols[name] = hv\n    self._counter += 1\n    return hv\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.add_many","title":"<code>add_many(names)</code>","text":"<p>Add multiple symbols to memory.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>Iterable[str]</code> <p>Iterable of symbol names to add.</p> required <p>Returns:</p> Type Description <code>list[AbstractHypervector]</code> <p>List of hypervectors corresponding to the added symbols.</p> Example <p>memory = VSAMemory(model) colors = memory.add_many([\"red\", \"green\", \"blue\"]) assert len(colors) == 3</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def add_many(self, names: Iterable[str]) -&gt; list[AbstractHypervector]:\n    \"\"\"Add multiple symbols to memory.\n\n    Args:\n        names: Iterable of symbol names to add.\n\n    Returns:\n        List of hypervectors corresponding to the added symbols.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; colors = memory.add_many([\"red\", \"green\", \"blue\"])\n        &gt;&gt;&gt; assert len(colors) == 3\n    \"\"\"\n    return [self.add(name) for name in names]\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.get","title":"<code>get(name)</code>","text":"<p>Get a hypervector by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the symbol to retrieve.</p> required <p>Returns:</p> Type Description <code>AbstractHypervector</code> <p>The hypervector associated with the symbol.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the symbol does not exist in memory.</p> Example <p>memory = VSAMemory(model) memory.add(\"dog\") dog = memory.get(\"dog\")</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def get(self, name: str) -&gt; AbstractHypervector:\n    \"\"\"Get a hypervector by name.\n\n    Args:\n        name: Name of the symbol to retrieve.\n\n    Returns:\n        The hypervector associated with the symbol.\n\n    Raises:\n        KeyError: If the symbol does not exist in memory.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"dog\")\n        &gt;&gt;&gt; dog = memory.get(\"dog\")\n    \"\"\"\n    return self._symbols[name]\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Get a hypervector by name using dictionary syntax.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the symbol to retrieve.</p> required <p>Returns:</p> Type Description <code>AbstractHypervector</code> <p>The hypervector associated with the symbol.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the symbol does not exist in memory.</p> Example <p>memory = VSAMemory(model) memory.add(\"dog\") dog = memory[\"dog\"]</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def __getitem__(self, name: str) -&gt; AbstractHypervector:\n    \"\"\"Get a hypervector by name using dictionary syntax.\n\n    Args:\n        name: Name of the symbol to retrieve.\n\n    Returns:\n        The hypervector associated with the symbol.\n\n    Raises:\n        KeyError: If the symbol does not exist in memory.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"dog\")\n        &gt;&gt;&gt; dog = memory[\"dog\"]\n    \"\"\"\n    return self.get(name)\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check if a symbol exists in memory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the symbol to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the symbol exists, False otherwise.</p> Example <p>memory = VSAMemory(model) memory.add(\"dog\") assert \"dog\" in memory assert \"cat\" not in memory</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def __contains__(self, name: str) -&gt; bool:\n    \"\"\"Check if a symbol exists in memory.\n\n    Args:\n        name: Name of the symbol to check.\n\n    Returns:\n        True if the symbol exists, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add(\"dog\")\n        &gt;&gt;&gt; assert \"dog\" in memory\n        &gt;&gt;&gt; assert \"cat\" not in memory\n    \"\"\"\n    return name in self._symbols\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.keys","title":"<code>keys()</code>","text":"<p>Get all symbol names in memory.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of symbol names.</p> Example <p>memory = VSAMemory(model) memory.add_many([\"a\", \"b\", \"c\"]) assert memory.keys() == [\"a\", \"b\", \"c\"]</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Get all symbol names in memory.\n\n    Returns:\n        List of symbol names.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n        &gt;&gt;&gt; assert memory.keys() == [\"a\", \"b\", \"c\"]\n    \"\"\"\n    return list(self._symbols.keys())\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of symbols in memory.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of stored symbols.</p> Example <p>memory = VSAMemory(model) memory.add_many([\"a\", \"b\", \"c\"]) assert len(memory) == 3</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get the number of symbols in memory.\n\n    Returns:\n        Number of stored symbols.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n        &gt;&gt;&gt; assert len(memory) == 3\n    \"\"\"\n    return len(self._symbols)\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.clear","title":"<code>clear()</code>","text":"<p>Remove all symbols from memory.</p> Example <p>memory = VSAMemory(model) memory.add_many([\"a\", \"b\", \"c\"]) memory.clear() assert len(memory) == 0</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all symbols from memory.\n\n    Example:\n        &gt;&gt;&gt; memory = VSAMemory(model)\n        &gt;&gt;&gt; memory.add_many([\"a\", \"b\", \"c\"])\n        &gt;&gt;&gt; memory.clear()\n        &gt;&gt;&gt; assert len(memory) == 0\n    \"\"\"\n    self._symbols.clear()\n    self._counter = 0\n</code></pre>"},{"location":"api/core/memory/#vsax.core.memory.VSAMemory.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of VSAMemory.</p> Source code in <code>vsax/core/memory.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of VSAMemory.\"\"\"\n    return f\"VSAMemory(model={self._model.rep_cls.__name__}, symbols={len(self._symbols)})\"\n</code></pre>"},{"location":"api/core/model/","title":"VSAModel","text":"<p>The immutable container that defines a complete VSA algebra.</p>"},{"location":"api/core/model/#vsax.core.model.VSAModel","title":"<code>vsax.core.model.VSAModel</code>  <code>dataclass</code>","text":"<p>Immutable container defining a complete VSA algebra.</p> <p>VSAModel combines a representation type, operation set, and sampling function to define a complete VSA system. It does not perform operations itself, but serves as a configuration object used by VSAMemory and encoders.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimensionality of all hypervectors in this model.</p> <code>rep_cls</code> <code>type[AbstractHypervector]</code> <p>The hypervector representation class (e.g., ComplexHypervector).</p> <code>opset</code> <code>AbstractOpSet</code> <p>The operation set instance defining bind/bundle/inverse operations.</p> <code>sampler</code> <code>Callable[[int, int, PRNGKey], ndarray]</code> <p>Function to sample random vectors with signature      (dim: int, n: int, key: PRNGKey) -&gt; jnp.ndarray.</p> Example <p>from vsax.representations import ComplexHypervector from vsax.ops import FHRROperations from vsax.sampling import sample_complex_random model = VSAModel( ...     dim=512, ...     rep_cls=ComplexHypervector, ...     opset=FHRROperations(), ...     sampler=sample_complex_random ... )</p> Source code in <code>vsax/core/model.py</code> <pre><code>@dataclass(frozen=True)\nclass VSAModel:\n    \"\"\"Immutable container defining a complete VSA algebra.\n\n    VSAModel combines a representation type, operation set, and sampling function\n    to define a complete VSA system. It does not perform operations itself, but\n    serves as a configuration object used by VSAMemory and encoders.\n\n    Attributes:\n        dim: Dimensionality of all hypervectors in this model.\n        rep_cls: The hypervector representation class (e.g., ComplexHypervector).\n        opset: The operation set instance defining bind/bundle/inverse operations.\n        sampler: Function to sample random vectors with signature\n                 (dim: int, n: int, key: PRNGKey) -&gt; jnp.ndarray.\n\n    Example:\n        &gt;&gt;&gt; from vsax.representations import ComplexHypervector\n        &gt;&gt;&gt; from vsax.ops import FHRROperations\n        &gt;&gt;&gt; from vsax.sampling import sample_complex_random\n        &gt;&gt;&gt; model = VSAModel(\n        ...     dim=512,\n        ...     rep_cls=ComplexHypervector,\n        ...     opset=FHRROperations(),\n        ...     sampler=sample_complex_random\n        ... )\n    \"\"\"\n\n    dim: int\n    rep_cls: type[AbstractHypervector]\n    opset: AbstractOpSet\n    sampler: Callable[[int, int, jax.random.PRNGKey], jnp.ndarray]\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate model parameters.\n\n        Raises:\n            ValueError: If dim is not positive.\n        \"\"\"\n        if self.dim &lt;= 0:\n            raise ValueError(f\"dim must be positive, got {self.dim}\")\n</code></pre>"},{"location":"api/core/model/#vsax.core.model.VSAModel-functions","title":"Functions","text":""},{"location":"api/core/model/#vsax.core.model.VSAModel.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate model parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dim is not positive.</p> Source code in <code>vsax/core/model.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate model parameters.\n\n    Raises:\n        ValueError: If dim is not positive.\n    \"\"\"\n    if self.dim &lt;= 0:\n        raise ValueError(f\"dim must be positive, got {self.dim}\")\n</code></pre>"},{"location":"api/ops/binary/","title":"BinaryOperations","text":"<p>XOR and majority voting operations for binary hypervectors.</p>"},{"location":"api/ops/binary/#vsax.ops.BinaryOperations","title":"<code>vsax.ops.BinaryOperations</code>","text":"<p>               Bases: <code>AbstractOpSet</code></p> <p>Binary VSA operations for bipolar {-1, +1} vectors.</p> <p>Binary VSA uses: - Binding: XOR (element-wise multiplication in bipolar representation) - Bundling: Majority vote - Inverse: Self-inverse (XOR is its own inverse)</p> <p>This algebra is particularly efficient for hardware implementation and provides exact unbinding (unlike MAP).</p> <p>Note: Operations assume bipolar {-1, +1} encoding. For {0, 1} encoding, convert to bipolar first.</p> Example <p>import jax import jax.numpy as jnp</p> <p>ops = BinaryOperations() key = jax.random.PRNGKey(0) a = jax.random.choice(key, jnp.array([-1, 1]), shape=(1024,)) b = jax.random.choice(key, jnp.array([-1, 1]), shape=(1024,))</p> <p>bound = ops.bind(a, b) assert jnp.all(jnp.isin(bound, jnp.array([-1, 1])))</p> Source code in <code>vsax/ops/binary.py</code> <pre><code>class BinaryOperations(AbstractOpSet):\n    \"\"\"Binary VSA operations for bipolar {-1, +1} vectors.\n\n    Binary VSA uses:\n    - Binding: XOR (element-wise multiplication in bipolar representation)\n    - Bundling: Majority vote\n    - Inverse: Self-inverse (XOR is its own inverse)\n\n    This algebra is particularly efficient for hardware implementation and\n    provides exact unbinding (unlike MAP).\n\n    Note: Operations assume bipolar {-1, +1} encoding. For {0, 1} encoding,\n    convert to bipolar first.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; ops = BinaryOperations()\n        &gt;&gt;&gt; key = jax.random.PRNGKey(0)\n        &gt;&gt;&gt; a = jax.random.choice(key, jnp.array([-1, 1]), shape=(1024,))\n        &gt;&gt;&gt; b = jax.random.choice(key, jnp.array([-1, 1]), shape=(1024,))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bound = ops.bind(a, b)\n        &gt;&gt;&gt; assert jnp.all(jnp.isin(bound, jnp.array([-1, 1])))\n    \"\"\"\n\n    def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bind two hypervectors using XOR (element-wise multiplication).\n\n        In bipolar {-1, +1} representation, XOR is implemented as\n        element-wise multiplication:\n        - (+1) XOR (+1) = +1 (same)\n        - (+1) XOR (-1) = -1 (different)\n        - (-1) XOR (+1) = -1 (different)\n        - (-1) XOR (-1) = +1 (same)\n\n        This operation is:\n        - Commutative: bind(a, b) = bind(b, a)\n        - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n        - Self-inverse: bind(bind(a, b), b) = a (exact unbinding)\n\n        Args:\n            a: First hypervector as JAX array (bipolar values).\n            b: Second hypervector as JAX array (bipolar values).\n\n        Returns:\n            Bound hypervector as JAX array (bipolar values).\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = BinaryOperations()\n            &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n            &gt;&gt;&gt; b = jnp.array([1, 1, -1, -1])\n            &gt;&gt;&gt; result = ops.bind(a, b)\n            &gt;&gt;&gt; expected = jnp.array([1, -1, -1, 1])\n            &gt;&gt;&gt; assert jnp.array_equal(result, expected)\n        \"\"\"\n        # XOR in bipolar is multiplication\n        return a * b\n\n    def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bundle multiple hypervectors using majority vote.\n\n        Each element in the bundled vector is determined by the majority\n        value at that position across all input vectors.\n\n        For even counts, ties are broken by the sign of the sum.\n\n        Args:\n            *vecs: Variable number of hypervectors as JAX arrays (bipolar values).\n\n        Returns:\n            Bundled hypervector as JAX array (bipolar values).\n\n        Raises:\n            ValueError: If no vectors are provided.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = BinaryOperations()\n            &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n            &gt;&gt;&gt; b = jnp.array([1, 1, -1, -1])\n            &gt;&gt;&gt; c = jnp.array([1, 1, 1, 1])\n            &gt;&gt;&gt; result = ops.bundle(a, b, c)\n            &gt;&gt;&gt; expected = jnp.array([1, 1, 1, -1])  # Majority at each position\n            &gt;&gt;&gt; assert jnp.array_equal(result, expected)\n        \"\"\"\n        if len(vecs) == 0:\n            raise ValueError(\"bundle() requires at least one vector\")\n\n        # Stack all vectors\n        stacked = jnp.stack(vecs)\n\n        # Sum across vectors (majority has positive/negative sum)\n        summed = jnp.sum(stacked, axis=0)\n\n        # Convert to bipolar: positive sum -&gt; +1, negative sum -&gt; -1\n        # Use sign function (0 maps to 0, but we'll handle that)\n        result = jnp.sign(summed)\n\n        # Handle zeros (ties) by defaulting to +1\n        result = jnp.where(result == 0, 1, result)\n\n        return result.astype(jnp.int32)\n\n    def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Compute the inverse for unbinding.\n\n        For binary XOR, the inverse is the vector itself (self-inverse property).\n        This means: bind(bind(a, b), b) = a (exact unbinding).\n\n        Args:\n            a: Hypervector as JAX array (bipolar values).\n\n        Returns:\n            Inverse hypervector (same as input for XOR).\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = BinaryOperations()\n            &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n            &gt;&gt;&gt; inv_a = ops.inverse(a)\n            &gt;&gt;&gt; assert jnp.array_equal(inv_a, a)\n        \"\"\"\n        # XOR is self-inverse\n        return a\n\n    def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n        \"\"\"Permute a hypervector by circular rotation.\n\n        Args:\n            a: Hypervector as JAX array (bipolar values).\n            shift: Number of positions to rotate (positive = right, negative = left).\n\n        Returns:\n            Permuted hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = BinaryOperations()\n            &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n            &gt;&gt;&gt; rotated = ops.permute(a, 1)\n            &gt;&gt;&gt; expected = jnp.array([-1, 1, -1, 1])\n            &gt;&gt;&gt; assert jnp.array_equal(rotated, expected)\n        \"\"\"\n        return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/ops/binary/#vsax.ops.BinaryOperations-functions","title":"Functions","text":""},{"location":"api/ops/binary/#vsax.ops.BinaryOperations.bind","title":"<code>bind(a, b)</code>","text":"<p>Bind two hypervectors using XOR (element-wise multiplication).</p> <p>In bipolar {-1, +1} representation, XOR is implemented as element-wise multiplication: - (+1) XOR (+1) = +1 (same) - (+1) XOR (-1) = -1 (different) - (-1) XOR (+1) = -1 (different) - (-1) XOR (-1) = +1 (same)</p> <p>This operation is: - Commutative: bind(a, b) = bind(b, a) - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c) - Self-inverse: bind(bind(a, b), b) = a (exact unbinding)</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>First hypervector as JAX array (bipolar values).</p> required <code>b</code> <code>ndarray</code> <p>Second hypervector as JAX array (bipolar values).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Bound hypervector as JAX array (bipolar values).</p> Example <p>import jax.numpy as jnp ops = BinaryOperations() a = jnp.array([1, -1, 1, -1]) b = jnp.array([1, 1, -1, -1]) result = ops.bind(a, b) expected = jnp.array([1, -1, -1, 1]) assert jnp.array_equal(result, expected)</p> Source code in <code>vsax/ops/binary.py</code> <pre><code>def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bind two hypervectors using XOR (element-wise multiplication).\n\n    In bipolar {-1, +1} representation, XOR is implemented as\n    element-wise multiplication:\n    - (+1) XOR (+1) = +1 (same)\n    - (+1) XOR (-1) = -1 (different)\n    - (-1) XOR (+1) = -1 (different)\n    - (-1) XOR (-1) = +1 (same)\n\n    This operation is:\n    - Commutative: bind(a, b) = bind(b, a)\n    - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n    - Self-inverse: bind(bind(a, b), b) = a (exact unbinding)\n\n    Args:\n        a: First hypervector as JAX array (bipolar values).\n        b: Second hypervector as JAX array (bipolar values).\n\n    Returns:\n        Bound hypervector as JAX array (bipolar values).\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = BinaryOperations()\n        &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n        &gt;&gt;&gt; b = jnp.array([1, 1, -1, -1])\n        &gt;&gt;&gt; result = ops.bind(a, b)\n        &gt;&gt;&gt; expected = jnp.array([1, -1, -1, 1])\n        &gt;&gt;&gt; assert jnp.array_equal(result, expected)\n    \"\"\"\n    # XOR in bipolar is multiplication\n    return a * b\n</code></pre>"},{"location":"api/ops/binary/#vsax.ops.BinaryOperations.bundle","title":"<code>bundle(*vecs)</code>","text":"<p>Bundle multiple hypervectors using majority vote.</p> <p>Each element in the bundled vector is determined by the majority value at that position across all input vectors.</p> <p>For even counts, ties are broken by the sign of the sum.</p> <p>Parameters:</p> Name Type Description Default <code>*vecs</code> <code>ndarray</code> <p>Variable number of hypervectors as JAX arrays (bipolar values).</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Bundled hypervector as JAX array (bipolar values).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no vectors are provided.</p> Example <p>import jax.numpy as jnp ops = BinaryOperations() a = jnp.array([1, -1, 1, -1]) b = jnp.array([1, 1, -1, -1]) c = jnp.array([1, 1, 1, 1]) result = ops.bundle(a, b, c) expected = jnp.array([1, 1, 1, -1])  # Majority at each position assert jnp.array_equal(result, expected)</p> Source code in <code>vsax/ops/binary.py</code> <pre><code>def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bundle multiple hypervectors using majority vote.\n\n    Each element in the bundled vector is determined by the majority\n    value at that position across all input vectors.\n\n    For even counts, ties are broken by the sign of the sum.\n\n    Args:\n        *vecs: Variable number of hypervectors as JAX arrays (bipolar values).\n\n    Returns:\n        Bundled hypervector as JAX array (bipolar values).\n\n    Raises:\n        ValueError: If no vectors are provided.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = BinaryOperations()\n        &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n        &gt;&gt;&gt; b = jnp.array([1, 1, -1, -1])\n        &gt;&gt;&gt; c = jnp.array([1, 1, 1, 1])\n        &gt;&gt;&gt; result = ops.bundle(a, b, c)\n        &gt;&gt;&gt; expected = jnp.array([1, 1, 1, -1])  # Majority at each position\n        &gt;&gt;&gt; assert jnp.array_equal(result, expected)\n    \"\"\"\n    if len(vecs) == 0:\n        raise ValueError(\"bundle() requires at least one vector\")\n\n    # Stack all vectors\n    stacked = jnp.stack(vecs)\n\n    # Sum across vectors (majority has positive/negative sum)\n    summed = jnp.sum(stacked, axis=0)\n\n    # Convert to bipolar: positive sum -&gt; +1, negative sum -&gt; -1\n    # Use sign function (0 maps to 0, but we'll handle that)\n    result = jnp.sign(summed)\n\n    # Handle zeros (ties) by defaulting to +1\n    result = jnp.where(result == 0, 1, result)\n\n    return result.astype(jnp.int32)\n</code></pre>"},{"location":"api/ops/binary/#vsax.ops.BinaryOperations.inverse","title":"<code>inverse(a)</code>","text":"<p>Compute the inverse for unbinding.</p> <p>For binary XOR, the inverse is the vector itself (self-inverse property). This means: bind(bind(a, b), b) = a (exact unbinding).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array (bipolar values).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Inverse hypervector (same as input for XOR).</p> Example <p>import jax.numpy as jnp ops = BinaryOperations() a = jnp.array([1, -1, 1, -1]) inv_a = ops.inverse(a) assert jnp.array_equal(inv_a, a)</p> Source code in <code>vsax/ops/binary.py</code> <pre><code>def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Compute the inverse for unbinding.\n\n    For binary XOR, the inverse is the vector itself (self-inverse property).\n    This means: bind(bind(a, b), b) = a (exact unbinding).\n\n    Args:\n        a: Hypervector as JAX array (bipolar values).\n\n    Returns:\n        Inverse hypervector (same as input for XOR).\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = BinaryOperations()\n        &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n        &gt;&gt;&gt; inv_a = ops.inverse(a)\n        &gt;&gt;&gt; assert jnp.array_equal(inv_a, a)\n    \"\"\"\n    # XOR is self-inverse\n    return a\n</code></pre>"},{"location":"api/ops/binary/#vsax.ops.BinaryOperations.permute","title":"<code>permute(a, shift)</code>","text":"<p>Permute a hypervector by circular rotation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array (bipolar values).</p> required <code>shift</code> <code>int</code> <p>Number of positions to rotate (positive = right, negative = left).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permuted hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = BinaryOperations() a = jnp.array([1, -1, 1, -1]) rotated = ops.permute(a, 1) expected = jnp.array([-1, 1, -1, 1]) assert jnp.array_equal(rotated, expected)</p> Source code in <code>vsax/ops/binary.py</code> <pre><code>def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n    \"\"\"Permute a hypervector by circular rotation.\n\n    Args:\n        a: Hypervector as JAX array (bipolar values).\n        shift: Number of positions to rotate (positive = right, negative = left).\n\n    Returns:\n        Permuted hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = BinaryOperations()\n        &gt;&gt;&gt; a = jnp.array([1, -1, 1, -1])\n        &gt;&gt;&gt; rotated = ops.permute(a, 1)\n        &gt;&gt;&gt; expected = jnp.array([-1, 1, -1, 1])\n        &gt;&gt;&gt; assert jnp.array_equal(rotated, expected)\n    \"\"\"\n    return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/ops/fhrr/","title":"FHRROperations","text":"<p>FFT-based operations for complex hypervectors.</p>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations","title":"<code>vsax.ops.FHRROperations</code>","text":"<p>               Bases: <code>AbstractOpSet</code></p> <p>FHRR operations using FFT-based circular convolution.</p> <p>Fourier Holographic Reduced Representation (FHRR) uses circular convolution for binding and complex addition for bundling. These operations work best with complex-valued hypervectors.</p> Binding is implemented via circular convolution in the frequency domain <p>bind(a, b) = IFFT(FFT(a) \u2299 FFT(b))</p> <p>where \u2299 denotes element-wise multiplication.</p> Example <p>import jax import jax.numpy as jnp from vsax.representations import ComplexHypervector</p> <p>ops = FHRROperations() key = jax.random.PRNGKey(0) a = jnp.exp(1j * jax.random.uniform(key, (512,), minval=0, maxval=2jnp.pi)) b = jnp.exp(1j * jax.random.uniform(key, (512,), minval=0, maxval=2jnp.pi))</p> <p>bound = ops.bind(a, b) assert bound.shape == a.shape</p> Source code in <code>vsax/ops/fhrr.py</code> <pre><code>class FHRROperations(AbstractOpSet):\n    \"\"\"FHRR operations using FFT-based circular convolution.\n\n    Fourier Holographic Reduced Representation (FHRR) uses circular convolution\n    for binding and complex addition for bundling. These operations work best\n    with complex-valued hypervectors.\n\n    Binding is implemented via circular convolution in the frequency domain:\n        bind(a, b) = IFFT(FFT(a) \u2299 FFT(b))\n\n    where \u2299 denotes element-wise multiplication.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; from vsax.representations import ComplexHypervector\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; ops = FHRROperations()\n        &gt;&gt;&gt; key = jax.random.PRNGKey(0)\n        &gt;&gt;&gt; a = jnp.exp(1j * jax.random.uniform(key, (512,), minval=0, maxval=2*jnp.pi))\n        &gt;&gt;&gt; b = jnp.exp(1j * jax.random.uniform(key, (512,), minval=0, maxval=2*jnp.pi))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bound = ops.bind(a, b)\n        &gt;&gt;&gt; assert bound.shape == a.shape\n    \"\"\"\n\n    def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bind two hypervectors using circular convolution.\n\n        Implemented via FFT: IFFT(FFT(a) * FFT(b))\n\n        This operation is:\n        - Commutative: bind(a, b) = bind(b, a)\n        - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n        - Invertible: bind(bind(a, b), inverse(b)) \u2248 a\n\n        Args:\n            a: First hypervector as JAX array.\n            b: Second hypervector as JAX array.\n\n        Returns:\n            Bound hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = FHRROperations()\n            &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5]))\n            &gt;&gt;&gt; b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1]))\n            &gt;&gt;&gt; result = ops.bind(a, b)\n            &gt;&gt;&gt; assert jnp.iscomplexobj(result)\n        \"\"\"\n        # Circular convolution via FFT\n        fft_a = jnp.fft.fft(a)\n        fft_b = jnp.fft.fft(b)\n        return jnp.fft.ifft(fft_a * fft_b)\n\n    def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bundle multiple hypervectors using complex addition and normalization.\n\n        The bundled vector is similar to all input vectors and can be queried\n        to retrieve the constituents.\n\n        Args:\n            *vecs: Variable number of hypervectors as JAX arrays.\n\n        Returns:\n            Bundled hypervector as JAX array, normalized to unit magnitude.\n\n        Raises:\n            ValueError: If no vectors are provided.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = FHRROperations()\n            &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.0, 0.5, 1.0]))\n            &gt;&gt;&gt; b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1]))\n            &gt;&gt;&gt; c = jnp.exp(1j * jnp.array([0.6, 0.9, 1.3]))\n            &gt;&gt;&gt; result = ops.bundle(a, b, c)\n            &gt;&gt;&gt; assert jnp.allclose(jnp.abs(result), 1.0, atol=0.1)\n        \"\"\"\n        if len(vecs) == 0:\n            raise ValueError(\"bundle() requires at least one vector\")\n\n        # Sum all vectors\n        result = jnp.sum(jnp.stack(vecs), axis=0)\n\n        # Normalize to unit magnitude (phase-only)\n        return result / jnp.abs(result)\n\n    def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Compute the inverse for unbinding.\n\n        For complex vectors, the inverse is the complex conjugate.\n        For real vectors, the inverse is the reversed vector (circular convolution inverse).\n\n        Args:\n            a: Hypervector as JAX array.\n\n        Returns:\n            Inverse hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = FHRROperations()\n            &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5]))\n            &gt;&gt;&gt; inv_a = ops.inverse(a)\n            &gt;&gt;&gt; # Binding with inverse should approximate identity\n            &gt;&gt;&gt; result = ops.bind(a, inv_a)\n            &gt;&gt;&gt; # Result should be close to all-ones vector (DC component)\n        \"\"\"\n        if jnp.iscomplexobj(a):\n            # Complex conjugate for complex vectors\n            return jnp.conj(a)\n        else:\n            # Reverse for real vectors (circular convolution inverse)\n            # Note: index 0 stays in place, rest are reversed\n            return jnp.concatenate([a[:1], jnp.flip(a[1:])])\n\n    def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n        \"\"\"Permute a hypervector by circular rotation.\n\n        Args:\n            a: Hypervector as JAX array.\n            shift: Number of positions to rotate (positive = right, negative = left).\n\n        Returns:\n            Permuted hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = FHRROperations()\n            &gt;&gt;&gt; a = jnp.array([1, 2, 3, 4, 5])\n            &gt;&gt;&gt; rotated = ops.permute(a, 2)\n            &gt;&gt;&gt; assert jnp.array_equal(rotated, jnp.array([4, 5, 1, 2, 3]))\n        \"\"\"\n        return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations-functions","title":"Functions","text":""},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.bind","title":"<code>bind(a, b)</code>","text":"<p>Bind two hypervectors using circular convolution.</p> <p>Implemented via FFT: IFFT(FFT(a) * FFT(b))</p> <p>This operation is: - Commutative: bind(a, b) = bind(b, a) - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c) - Invertible: bind(bind(a, b), inverse(b)) \u2248 a</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>First hypervector as JAX array.</p> required <code>b</code> <code>ndarray</code> <p>Second hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Bound hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = FHRROperations() a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5])) b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1])) result = ops.bind(a, b) assert jnp.iscomplexobj(result)</p> Source code in <code>vsax/ops/fhrr.py</code> <pre><code>def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bind two hypervectors using circular convolution.\n\n    Implemented via FFT: IFFT(FFT(a) * FFT(b))\n\n    This operation is:\n    - Commutative: bind(a, b) = bind(b, a)\n    - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n    - Invertible: bind(bind(a, b), inverse(b)) \u2248 a\n\n    Args:\n        a: First hypervector as JAX array.\n        b: Second hypervector as JAX array.\n\n    Returns:\n        Bound hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = FHRROperations()\n        &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5]))\n        &gt;&gt;&gt; b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1]))\n        &gt;&gt;&gt; result = ops.bind(a, b)\n        &gt;&gt;&gt; assert jnp.iscomplexobj(result)\n    \"\"\"\n    # Circular convolution via FFT\n    fft_a = jnp.fft.fft(a)\n    fft_b = jnp.fft.fft(b)\n    return jnp.fft.ifft(fft_a * fft_b)\n</code></pre>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.bundle","title":"<code>bundle(*vecs)</code>","text":"<p>Bundle multiple hypervectors using complex addition and normalization.</p> <p>The bundled vector is similar to all input vectors and can be queried to retrieve the constituents.</p> <p>Parameters:</p> Name Type Description Default <code>*vecs</code> <code>ndarray</code> <p>Variable number of hypervectors as JAX arrays.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Bundled hypervector as JAX array, normalized to unit magnitude.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no vectors are provided.</p> Example <p>import jax.numpy as jnp ops = FHRROperations() a = jnp.exp(1j * jnp.array([0.0, 0.5, 1.0])) b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1])) c = jnp.exp(1j * jnp.array([0.6, 0.9, 1.3])) result = ops.bundle(a, b, c) assert jnp.allclose(jnp.abs(result), 1.0, atol=0.1)</p> Source code in <code>vsax/ops/fhrr.py</code> <pre><code>def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bundle multiple hypervectors using complex addition and normalization.\n\n    The bundled vector is similar to all input vectors and can be queried\n    to retrieve the constituents.\n\n    Args:\n        *vecs: Variable number of hypervectors as JAX arrays.\n\n    Returns:\n        Bundled hypervector as JAX array, normalized to unit magnitude.\n\n    Raises:\n        ValueError: If no vectors are provided.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = FHRROperations()\n        &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.0, 0.5, 1.0]))\n        &gt;&gt;&gt; b = jnp.exp(1j * jnp.array([0.3, 0.7, 1.1]))\n        &gt;&gt;&gt; c = jnp.exp(1j * jnp.array([0.6, 0.9, 1.3]))\n        &gt;&gt;&gt; result = ops.bundle(a, b, c)\n        &gt;&gt;&gt; assert jnp.allclose(jnp.abs(result), 1.0, atol=0.1)\n    \"\"\"\n    if len(vecs) == 0:\n        raise ValueError(\"bundle() requires at least one vector\")\n\n    # Sum all vectors\n    result = jnp.sum(jnp.stack(vecs), axis=0)\n\n    # Normalize to unit magnitude (phase-only)\n    return result / jnp.abs(result)\n</code></pre>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.inverse","title":"<code>inverse(a)</code>","text":"<p>Compute the inverse for unbinding.</p> <p>For complex vectors, the inverse is the complex conjugate. For real vectors, the inverse is the reversed vector (circular convolution inverse).</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Inverse hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = FHRROperations() a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5])) inv_a = ops.inverse(a)</p> Source code in <code>vsax/ops/fhrr.py</code> <pre><code>def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Compute the inverse for unbinding.\n\n    For complex vectors, the inverse is the complex conjugate.\n    For real vectors, the inverse is the reversed vector (circular convolution inverse).\n\n    Args:\n        a: Hypervector as JAX array.\n\n    Returns:\n        Inverse hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = FHRROperations()\n        &gt;&gt;&gt; a = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5]))\n        &gt;&gt;&gt; inv_a = ops.inverse(a)\n        &gt;&gt;&gt; # Binding with inverse should approximate identity\n        &gt;&gt;&gt; result = ops.bind(a, inv_a)\n        &gt;&gt;&gt; # Result should be close to all-ones vector (DC component)\n    \"\"\"\n    if jnp.iscomplexobj(a):\n        # Complex conjugate for complex vectors\n        return jnp.conj(a)\n    else:\n        # Reverse for real vectors (circular convolution inverse)\n        # Note: index 0 stays in place, rest are reversed\n        return jnp.concatenate([a[:1], jnp.flip(a[1:])])\n</code></pre>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.inverse--binding-with-inverse-should-approximate-identity","title":"Binding with inverse should approximate identity","text":"<p>result = ops.bind(a, inv_a)</p>"},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.inverse--result-should-be-close-to-all-ones-vector-dc-component","title":"Result should be close to all-ones vector (DC component)","text":""},{"location":"api/ops/fhrr/#vsax.ops.FHRROperations.permute","title":"<code>permute(a, shift)</code>","text":"<p>Permute a hypervector by circular rotation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <code>shift</code> <code>int</code> <p>Number of positions to rotate (positive = right, negative = left).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permuted hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = FHRROperations() a = jnp.array([1, 2, 3, 4, 5]) rotated = ops.permute(a, 2) assert jnp.array_equal(rotated, jnp.array([4, 5, 1, 2, 3]))</p> Source code in <code>vsax/ops/fhrr.py</code> <pre><code>def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n    \"\"\"Permute a hypervector by circular rotation.\n\n    Args:\n        a: Hypervector as JAX array.\n        shift: Number of positions to rotate (positive = right, negative = left).\n\n    Returns:\n        Permuted hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = FHRROperations()\n        &gt;&gt;&gt; a = jnp.array([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; rotated = ops.permute(a, 2)\n        &gt;&gt;&gt; assert jnp.array_equal(rotated, jnp.array([4, 5, 1, 2, 3]))\n    \"\"\"\n    return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/ops/map/","title":"MAPOperations","text":"<p>Element-wise operations for real hypervectors.</p>"},{"location":"api/ops/map/#vsax.ops.MAPOperations","title":"<code>vsax.ops.MAPOperations</code>","text":"<p>               Bases: <code>AbstractOpSet</code></p> <p>MAP operations using element-wise multiplication and mean.</p> <p>Multiply-Add-Permute (MAP) is a simple VSA algebra that uses: - Binding: element-wise multiplication - Bundling: element-wise mean (averaging) - Inverse: approximate inverse via normalization</p> <p>MAP works best with real-valued hypervectors and is computationally efficient, making it suitable for machine learning applications.</p> Example <p>import jax import jax.numpy as jnp</p> <p>ops = MAPOperations() key = jax.random.PRNGKey(0) a = jax.random.normal(key, (1024,)) b = jax.random.normal(key, (1024,))</p> <p>bound = ops.bind(a, b) assert bound.shape == a.shape</p> Source code in <code>vsax/ops/map.py</code> <pre><code>class MAPOperations(AbstractOpSet):\n    \"\"\"MAP operations using element-wise multiplication and mean.\n\n    Multiply-Add-Permute (MAP) is a simple VSA algebra that uses:\n    - Binding: element-wise multiplication\n    - Bundling: element-wise mean (averaging)\n    - Inverse: approximate inverse via normalization\n\n    MAP works best with real-valued hypervectors and is computationally\n    efficient, making it suitable for machine learning applications.\n\n    Example:\n        &gt;&gt;&gt; import jax\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; ops = MAPOperations()\n        &gt;&gt;&gt; key = jax.random.PRNGKey(0)\n        &gt;&gt;&gt; a = jax.random.normal(key, (1024,))\n        &gt;&gt;&gt; b = jax.random.normal(key, (1024,))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bound = ops.bind(a, b)\n        &gt;&gt;&gt; assert bound.shape == a.shape\n    \"\"\"\n\n    def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bind two hypervectors using element-wise multiplication.\n\n        This operation is:\n        - Commutative: bind(a, b) = bind(b, a)\n        - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n        - Approximately invertible with the inverse() operation\n\n        Args:\n            a: First hypervector as JAX array.\n            b: Second hypervector as JAX array.\n\n        Returns:\n            Bound hypervector as JAX array (element-wise product).\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = MAPOperations()\n            &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0])\n            &gt;&gt;&gt; b = jnp.array([2.0, 3.0, 4.0])\n            &gt;&gt;&gt; result = ops.bind(a, b)\n            &gt;&gt;&gt; assert jnp.array_equal(result, jnp.array([2.0, 6.0, 12.0]))\n        \"\"\"\n        return a * b\n\n    def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Bundle multiple hypervectors using element-wise mean.\n\n        The bundled vector is the average of all input vectors, providing\n        a representation that is similar to all inputs.\n\n        Args:\n            *vecs: Variable number of hypervectors as JAX arrays.\n\n        Returns:\n            Bundled hypervector as JAX array (element-wise mean).\n\n        Raises:\n            ValueError: If no vectors are provided.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = MAPOperations()\n            &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0])\n            &gt;&gt;&gt; b = jnp.array([3.0, 4.0, 5.0])\n            &gt;&gt;&gt; c = jnp.array([5.0, 6.0, 7.0])\n            &gt;&gt;&gt; result = ops.bundle(a, b, c)\n            &gt;&gt;&gt; expected = jnp.array([3.0, 4.0, 5.0])\n            &gt;&gt;&gt; assert jnp.allclose(result, expected)\n        \"\"\"\n        if len(vecs) == 0:\n            raise ValueError(\"bundle() requires at least one vector\")\n\n        return jnp.mean(jnp.stack(vecs), axis=0)\n\n    def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"Compute approximate inverse for unbinding.\n\n        For MAP, the inverse is approximated by the normalized vector itself.\n        This works because binding with a normalized vector approximately\n        projects onto the orthogonal complement.\n\n        Note: This is an approximation. Perfect unbinding is not guaranteed.\n\n        Args:\n            a: Hypervector as JAX array.\n\n        Returns:\n            Approximate inverse hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = MAPOperations()\n            &gt;&gt;&gt; a = jnp.array([3.0, 4.0])\n            &gt;&gt;&gt; inv_a = ops.inverse(a)\n            &gt;&gt;&gt; # The inverse should be normalized\n            &gt;&gt;&gt; assert jnp.allclose(jnp.linalg.norm(inv_a), 1.0, atol=1e-6)\n        \"\"\"\n        # Normalize the vector as an approximate inverse\n        # This works because: a * (a / ||a||\u00b2) \u2248 a\u00b2/||a||\u00b2\n        norm_squared = jnp.sum(a**2)\n        return a / (norm_squared + 1e-8)\n\n    def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n        \"\"\"Permute a hypervector by circular rotation.\n\n        Args:\n            a: Hypervector as JAX array.\n            shift: Number of positions to rotate (positive = right, negative = left).\n\n        Returns:\n            Permuted hypervector as JAX array.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; ops = MAPOperations()\n            &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0, 4.0])\n            &gt;&gt;&gt; rotated = ops.permute(a, 1)\n            &gt;&gt;&gt; expected = jnp.array([4.0, 1.0, 2.0, 3.0])\n            &gt;&gt;&gt; assert jnp.array_equal(rotated, expected)\n        \"\"\"\n        return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/ops/map/#vsax.ops.MAPOperations-functions","title":"Functions","text":""},{"location":"api/ops/map/#vsax.ops.MAPOperations.bind","title":"<code>bind(a, b)</code>","text":"<p>Bind two hypervectors using element-wise multiplication.</p> <p>This operation is: - Commutative: bind(a, b) = bind(b, a) - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c) - Approximately invertible with the inverse() operation</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>First hypervector as JAX array.</p> required <code>b</code> <code>ndarray</code> <p>Second hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Bound hypervector as JAX array (element-wise product).</p> Example <p>import jax.numpy as jnp ops = MAPOperations() a = jnp.array([1.0, 2.0, 3.0]) b = jnp.array([2.0, 3.0, 4.0]) result = ops.bind(a, b) assert jnp.array_equal(result, jnp.array([2.0, 6.0, 12.0]))</p> Source code in <code>vsax/ops/map.py</code> <pre><code>def bind(self, a: jnp.ndarray, b: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bind two hypervectors using element-wise multiplication.\n\n    This operation is:\n    - Commutative: bind(a, b) = bind(b, a)\n    - Associative: bind(a, bind(b, c)) = bind(bind(a, b), c)\n    - Approximately invertible with the inverse() operation\n\n    Args:\n        a: First hypervector as JAX array.\n        b: Second hypervector as JAX array.\n\n    Returns:\n        Bound hypervector as JAX array (element-wise product).\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = MAPOperations()\n        &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0])\n        &gt;&gt;&gt; b = jnp.array([2.0, 3.0, 4.0])\n        &gt;&gt;&gt; result = ops.bind(a, b)\n        &gt;&gt;&gt; assert jnp.array_equal(result, jnp.array([2.0, 6.0, 12.0]))\n    \"\"\"\n    return a * b\n</code></pre>"},{"location":"api/ops/map/#vsax.ops.MAPOperations.bundle","title":"<code>bundle(*vecs)</code>","text":"<p>Bundle multiple hypervectors using element-wise mean.</p> <p>The bundled vector is the average of all input vectors, providing a representation that is similar to all inputs.</p> <p>Parameters:</p> Name Type Description Default <code>*vecs</code> <code>ndarray</code> <p>Variable number of hypervectors as JAX arrays.</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Bundled hypervector as JAX array (element-wise mean).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no vectors are provided.</p> Example <p>import jax.numpy as jnp ops = MAPOperations() a = jnp.array([1.0, 2.0, 3.0]) b = jnp.array([3.0, 4.0, 5.0]) c = jnp.array([5.0, 6.0, 7.0]) result = ops.bundle(a, b, c) expected = jnp.array([3.0, 4.0, 5.0]) assert jnp.allclose(result, expected)</p> Source code in <code>vsax/ops/map.py</code> <pre><code>def bundle(self, *vecs: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Bundle multiple hypervectors using element-wise mean.\n\n    The bundled vector is the average of all input vectors, providing\n    a representation that is similar to all inputs.\n\n    Args:\n        *vecs: Variable number of hypervectors as JAX arrays.\n\n    Returns:\n        Bundled hypervector as JAX array (element-wise mean).\n\n    Raises:\n        ValueError: If no vectors are provided.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = MAPOperations()\n        &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0])\n        &gt;&gt;&gt; b = jnp.array([3.0, 4.0, 5.0])\n        &gt;&gt;&gt; c = jnp.array([5.0, 6.0, 7.0])\n        &gt;&gt;&gt; result = ops.bundle(a, b, c)\n        &gt;&gt;&gt; expected = jnp.array([3.0, 4.0, 5.0])\n        &gt;&gt;&gt; assert jnp.allclose(result, expected)\n    \"\"\"\n    if len(vecs) == 0:\n        raise ValueError(\"bundle() requires at least one vector\")\n\n    return jnp.mean(jnp.stack(vecs), axis=0)\n</code></pre>"},{"location":"api/ops/map/#vsax.ops.MAPOperations.inverse","title":"<code>inverse(a)</code>","text":"<p>Compute approximate inverse for unbinding.</p> <p>For MAP, the inverse is approximated by the normalized vector itself. This works because binding with a normalized vector approximately projects onto the orthogonal complement.</p> <p>Note: This is an approximation. Perfect unbinding is not guaranteed.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Approximate inverse hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = MAPOperations() a = jnp.array([3.0, 4.0]) inv_a = ops.inverse(a)</p> Source code in <code>vsax/ops/map.py</code> <pre><code>def inverse(self, a: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Compute approximate inverse for unbinding.\n\n    For MAP, the inverse is approximated by the normalized vector itself.\n    This works because binding with a normalized vector approximately\n    projects onto the orthogonal complement.\n\n    Note: This is an approximation. Perfect unbinding is not guaranteed.\n\n    Args:\n        a: Hypervector as JAX array.\n\n    Returns:\n        Approximate inverse hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = MAPOperations()\n        &gt;&gt;&gt; a = jnp.array([3.0, 4.0])\n        &gt;&gt;&gt; inv_a = ops.inverse(a)\n        &gt;&gt;&gt; # The inverse should be normalized\n        &gt;&gt;&gt; assert jnp.allclose(jnp.linalg.norm(inv_a), 1.0, atol=1e-6)\n    \"\"\"\n    # Normalize the vector as an approximate inverse\n    # This works because: a * (a / ||a||\u00b2) \u2248 a\u00b2/||a||\u00b2\n    norm_squared = jnp.sum(a**2)\n    return a / (norm_squared + 1e-8)\n</code></pre>"},{"location":"api/ops/map/#vsax.ops.MAPOperations.inverse--the-inverse-should-be-normalized","title":"The inverse should be normalized","text":"<p>assert jnp.allclose(jnp.linalg.norm(inv_a), 1.0, atol=1e-6)</p>"},{"location":"api/ops/map/#vsax.ops.MAPOperations.permute","title":"<code>permute(a, shift)</code>","text":"<p>Permute a hypervector by circular rotation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>Hypervector as JAX array.</p> required <code>shift</code> <code>int</code> <p>Number of positions to rotate (positive = right, negative = left).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Permuted hypervector as JAX array.</p> Example <p>import jax.numpy as jnp ops = MAPOperations() a = jnp.array([1.0, 2.0, 3.0, 4.0]) rotated = ops.permute(a, 1) expected = jnp.array([4.0, 1.0, 2.0, 3.0]) assert jnp.array_equal(rotated, expected)</p> Source code in <code>vsax/ops/map.py</code> <pre><code>def permute(self, a: jnp.ndarray, shift: int) -&gt; jnp.ndarray:\n    \"\"\"Permute a hypervector by circular rotation.\n\n    Args:\n        a: Hypervector as JAX array.\n        shift: Number of positions to rotate (positive = right, negative = left).\n\n    Returns:\n        Permuted hypervector as JAX array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; ops = MAPOperations()\n        &gt;&gt;&gt; a = jnp.array([1.0, 2.0, 3.0, 4.0])\n        &gt;&gt;&gt; rotated = ops.permute(a, 1)\n        &gt;&gt;&gt; expected = jnp.array([4.0, 1.0, 2.0, 3.0])\n        &gt;&gt;&gt; assert jnp.array_equal(rotated, expected)\n    \"\"\"\n    return jnp.roll(a, shift)\n</code></pre>"},{"location":"api/representations/binary/","title":"BinaryHypervector","text":"<p>Binary hypervector with bipolar or binary encoding.</p>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector","title":"<code>vsax.representations.BinaryHypervector</code>","text":"<p>               Bases: <code>AbstractHypervector</code></p> <p>Binary hypervector with bipolar {-1, +1} or binary {0, 1} values.</p> <p>BinaryHypervector represents hypervectors using discrete binary values. It supports two modes: - Bipolar: values in {-1, +1} (default, recommended) - Binary: values in {0, 1}</p> <p>Binary hypervectors are efficient for hardware implementation and provide good performance with XOR binding and majority bundling operations.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>JAX array containing binary values.</p> required <code>bipolar</code> <code>bool</code> <p>If True, expects {-1, +1} values. If False, expects {0, 1} values.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If vec contains values outside the expected binary set.</p> Example <p>import jax.numpy as jnp vec = jnp.array([1, -1, 1, -1]) hv = BinaryHypervector(vec, bipolar=True) normalized = hv.normalize()  # No-op for binary assert jnp.array_equal(normalized.vec, vec)</p> Source code in <code>vsax/representations/binary_hv.py</code> <pre><code>class BinaryHypervector(AbstractHypervector):\n    \"\"\"Binary hypervector with bipolar {-1, +1} or binary {0, 1} values.\n\n    BinaryHypervector represents hypervectors using discrete binary values.\n    It supports two modes:\n    - Bipolar: values in {-1, +1} (default, recommended)\n    - Binary: values in {0, 1}\n\n    Binary hypervectors are efficient for hardware implementation and provide\n    good performance with XOR binding and majority bundling operations.\n\n    Args:\n        vec: JAX array containing binary values.\n        bipolar: If True, expects {-1, +1} values. If False, expects {0, 1} values.\n\n    Raises:\n        ValueError: If vec contains values outside the expected binary set.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([1, -1, 1, -1])\n        &gt;&gt;&gt; hv = BinaryHypervector(vec, bipolar=True)\n        &gt;&gt;&gt; normalized = hv.normalize()  # No-op for binary\n        &gt;&gt;&gt; assert jnp.array_equal(normalized.vec, vec)\n    \"\"\"\n\n    def __init__(self, vec: jnp.ndarray, bipolar: bool = True) -&gt; None:\n        \"\"\"Initialize binary hypervector.\n\n        Args:\n            vec: JAX array with binary values.\n            bipolar: If True, values should be {-1, +1}.\n                    If False, values should be {0, 1}.\n\n        Raises:\n            ValueError: If vec contains invalid values for the chosen mode.\n        \"\"\"\n        self._bipolar = bipolar\n\n        # Validate binary values\n        unique_vals = jnp.unique(vec)\n\n        if bipolar:\n            valid_set = jnp.array([-1, 1])\n            if not jnp.all(jnp.isin(unique_vals, valid_set)):\n                raise ValueError(\n                    f\"Bipolar binary vector must contain only -1 or +1, \"\n                    f\"got unique values: {unique_vals}\"\n                )\n        else:\n            valid_set = jnp.array([0, 1])\n            if not jnp.all(jnp.isin(unique_vals, valid_set)):\n                raise ValueError(\n                    f\"Non-bipolar binary vector must contain only 0 or 1, \"\n                    f\"got unique values: {unique_vals}\"\n                )\n\n        super().__init__(vec)\n\n    def normalize(self) -&gt; \"BinaryHypervector\":\n        \"\"\"No-op normalization for binary hypervectors.\n\n        Binary hypervectors are already in their normalized form.\n\n        Returns:\n            A new BinaryHypervector with the same values.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([1, -1, 1])\n            &gt;&gt;&gt; hv = BinaryHypervector(vec)\n            &gt;&gt;&gt; normalized = hv.normalize()\n            &gt;&gt;&gt; assert jnp.array_equal(normalized.vec, vec)\n        \"\"\"\n        return BinaryHypervector(self._vec, bipolar=self._bipolar)\n\n    @property\n    def bipolar(self) -&gt; bool:\n        \"\"\"Check if hypervector uses bipolar {-1, +1} encoding.\n\n        Returns:\n            True if bipolar, False if binary {0, 1}.\n        \"\"\"\n        return self._bipolar\n\n    def to_bipolar(self) -&gt; \"BinaryHypervector\":\n        \"\"\"Convert to bipolar {-1, +1} representation.\n\n        Returns:\n            New BinaryHypervector in bipolar form.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([0, 1, 0, 1])\n            &gt;&gt;&gt; hv = BinaryHypervector(vec, bipolar=False)\n            &gt;&gt;&gt; bipolar_hv = hv.to_bipolar()\n            &gt;&gt;&gt; assert jnp.array_equal(bipolar_hv.vec, jnp.array([-1, 1, -1, 1]))\n        \"\"\"\n        if self._bipolar:\n            return self\n        # Convert {0, 1} to {-1, +1}: 2*x - 1\n        bipolar_vec = 2 * self._vec - 1\n        return BinaryHypervector(bipolar_vec, bipolar=True)\n\n    def to_binary(self) -&gt; \"BinaryHypervector\":\n        \"\"\"Convert to binary {0, 1} representation.\n\n        Returns:\n            New BinaryHypervector in binary form.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([-1, 1, -1, 1])\n            &gt;&gt;&gt; hv = BinaryHypervector(vec, bipolar=True)\n            &gt;&gt;&gt; binary_hv = hv.to_binary()\n            &gt;&gt;&gt; assert jnp.array_equal(binary_hv.vec, jnp.array([0, 1, 0, 1]))\n        \"\"\"\n        if not self._bipolar:\n            return self\n        # Convert {-1, +1} to {0, 1}: (x + 1) / 2\n        binary_vec = (self._vec + 1) // 2\n        return BinaryHypervector(binary_vec, bipolar=False)\n</code></pre>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector-attributes","title":"Attributes","text":""},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector.bipolar","title":"<code>bipolar</code>  <code>property</code>","text":"<p>Check if hypervector uses bipolar {-1, +1} encoding.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if bipolar, False if binary {0, 1}.</p>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector-functions","title":"Functions","text":""},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector.__init__","title":"<code>__init__(vec, bipolar=True)</code>","text":"<p>Initialize binary hypervector.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>JAX array with binary values.</p> required <code>bipolar</code> <code>bool</code> <p>If True, values should be {-1, +1}.     If False, values should be {0, 1}.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If vec contains invalid values for the chosen mode.</p> Source code in <code>vsax/representations/binary_hv.py</code> <pre><code>def __init__(self, vec: jnp.ndarray, bipolar: bool = True) -&gt; None:\n    \"\"\"Initialize binary hypervector.\n\n    Args:\n        vec: JAX array with binary values.\n        bipolar: If True, values should be {-1, +1}.\n                If False, values should be {0, 1}.\n\n    Raises:\n        ValueError: If vec contains invalid values for the chosen mode.\n    \"\"\"\n    self._bipolar = bipolar\n\n    # Validate binary values\n    unique_vals = jnp.unique(vec)\n\n    if bipolar:\n        valid_set = jnp.array([-1, 1])\n        if not jnp.all(jnp.isin(unique_vals, valid_set)):\n            raise ValueError(\n                f\"Bipolar binary vector must contain only -1 or +1, \"\n                f\"got unique values: {unique_vals}\"\n            )\n    else:\n        valid_set = jnp.array([0, 1])\n        if not jnp.all(jnp.isin(unique_vals, valid_set)):\n            raise ValueError(\n                f\"Non-bipolar binary vector must contain only 0 or 1, \"\n                f\"got unique values: {unique_vals}\"\n            )\n\n    super().__init__(vec)\n</code></pre>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector.normalize","title":"<code>normalize()</code>","text":"<p>No-op normalization for binary hypervectors.</p> <p>Binary hypervectors are already in their normalized form.</p> <p>Returns:</p> Type Description <code>BinaryHypervector</code> <p>A new BinaryHypervector with the same values.</p> Example <p>import jax.numpy as jnp vec = jnp.array([1, -1, 1]) hv = BinaryHypervector(vec) normalized = hv.normalize() assert jnp.array_equal(normalized.vec, vec)</p> Source code in <code>vsax/representations/binary_hv.py</code> <pre><code>def normalize(self) -&gt; \"BinaryHypervector\":\n    \"\"\"No-op normalization for binary hypervectors.\n\n    Binary hypervectors are already in their normalized form.\n\n    Returns:\n        A new BinaryHypervector with the same values.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([1, -1, 1])\n        &gt;&gt;&gt; hv = BinaryHypervector(vec)\n        &gt;&gt;&gt; normalized = hv.normalize()\n        &gt;&gt;&gt; assert jnp.array_equal(normalized.vec, vec)\n    \"\"\"\n    return BinaryHypervector(self._vec, bipolar=self._bipolar)\n</code></pre>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector.to_bipolar","title":"<code>to_bipolar()</code>","text":"<p>Convert to bipolar {-1, +1} representation.</p> <p>Returns:</p> Type Description <code>BinaryHypervector</code> <p>New BinaryHypervector in bipolar form.</p> Example <p>import jax.numpy as jnp vec = jnp.array([0, 1, 0, 1]) hv = BinaryHypervector(vec, bipolar=False) bipolar_hv = hv.to_bipolar() assert jnp.array_equal(bipolar_hv.vec, jnp.array([-1, 1, -1, 1]))</p> Source code in <code>vsax/representations/binary_hv.py</code> <pre><code>def to_bipolar(self) -&gt; \"BinaryHypervector\":\n    \"\"\"Convert to bipolar {-1, +1} representation.\n\n    Returns:\n        New BinaryHypervector in bipolar form.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([0, 1, 0, 1])\n        &gt;&gt;&gt; hv = BinaryHypervector(vec, bipolar=False)\n        &gt;&gt;&gt; bipolar_hv = hv.to_bipolar()\n        &gt;&gt;&gt; assert jnp.array_equal(bipolar_hv.vec, jnp.array([-1, 1, -1, 1]))\n    \"\"\"\n    if self._bipolar:\n        return self\n    # Convert {0, 1} to {-1, +1}: 2*x - 1\n    bipolar_vec = 2 * self._vec - 1\n    return BinaryHypervector(bipolar_vec, bipolar=True)\n</code></pre>"},{"location":"api/representations/binary/#vsax.representations.BinaryHypervector.to_binary","title":"<code>to_binary()</code>","text":"<p>Convert to binary {0, 1} representation.</p> <p>Returns:</p> Type Description <code>BinaryHypervector</code> <p>New BinaryHypervector in binary form.</p> Example <p>import jax.numpy as jnp vec = jnp.array([-1, 1, -1, 1]) hv = BinaryHypervector(vec, bipolar=True) binary_hv = hv.to_binary() assert jnp.array_equal(binary_hv.vec, jnp.array([0, 1, 0, 1]))</p> Source code in <code>vsax/representations/binary_hv.py</code> <pre><code>def to_binary(self) -&gt; \"BinaryHypervector\":\n    \"\"\"Convert to binary {0, 1} representation.\n\n    Returns:\n        New BinaryHypervector in binary form.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([-1, 1, -1, 1])\n        &gt;&gt;&gt; hv = BinaryHypervector(vec, bipolar=True)\n        &gt;&gt;&gt; binary_hv = hv.to_binary()\n        &gt;&gt;&gt; assert jnp.array_equal(binary_hv.vec, jnp.array([0, 1, 0, 1]))\n    \"\"\"\n    if not self._bipolar:\n        return self\n    # Convert {-1, +1} to {0, 1}: (x + 1) / 2\n    binary_vec = (self._vec + 1) // 2\n    return BinaryHypervector(binary_vec, bipolar=False)\n</code></pre>"},{"location":"api/representations/complex/","title":"ComplexHypervector","text":"<p>Phase-based complex-valued hypervector for FHRR operations.</p>"},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector","title":"<code>vsax.representations.ComplexHypervector</code>","text":"<p>               Bases: <code>AbstractHypervector</code></p> <p>Phase-based complex-valued hypervector for FHRR.</p> <p>ComplexHypervector uses complex numbers to represent hypervectors, where the phase component encodes information. This is particularly useful for Fourier Holographic Reduced Representation (FHRR) operations.</p> <p>The normalization operation sets all elements to unit magnitude, preserving only the phase information.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>Complex-valued JAX array representing the hypervector.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If vec is not a complex array.</p> Example <p>import jax.numpy as jnp vec = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5])) hv = ComplexHypervector(vec) normalized = hv.normalize() assert jnp.allclose(jnp.abs(normalized.vec), 1.0)</p> Source code in <code>vsax/representations/complex_hv.py</code> <pre><code>class ComplexHypervector(AbstractHypervector):\n    \"\"\"Phase-based complex-valued hypervector for FHRR.\n\n    ComplexHypervector uses complex numbers to represent hypervectors, where\n    the phase component encodes information. This is particularly useful for\n    Fourier Holographic Reduced Representation (FHRR) operations.\n\n    The normalization operation sets all elements to unit magnitude, preserving\n    only the phase information.\n\n    Args:\n        vec: Complex-valued JAX array representing the hypervector.\n\n    Raises:\n        TypeError: If vec is not a complex array.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.exp(1j * jnp.array([0.5, 1.0, 1.5]))\n        &gt;&gt;&gt; hv = ComplexHypervector(vec)\n        &gt;&gt;&gt; normalized = hv.normalize()\n        &gt;&gt;&gt; assert jnp.allclose(jnp.abs(normalized.vec), 1.0)\n    \"\"\"\n\n    def __init__(self, vec: jnp.ndarray) -&gt; None:\n        \"\"\"Initialize complex hypervector.\n\n        Args:\n            vec: Complex-valued JAX array.\n\n        Raises:\n            TypeError: If vec is not complex-valued.\n        \"\"\"\n        if not jnp.iscomplexobj(vec):\n            raise TypeError(\n                f\"ComplexHypervector requires complex array, got {vec.dtype}\"\n            )\n        super().__init__(vec)\n\n    def normalize(self) -&gt; \"ComplexHypervector\":\n        \"\"\"Normalize to unit magnitude (phase-only representation).\n\n        Returns:\n            New ComplexHypervector with all elements having magnitude 1.0,\n            preserving the phase angles.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([3+4j, 5+12j])\n            &gt;&gt;&gt; hv = ComplexHypervector(vec)\n            &gt;&gt;&gt; normalized = hv.normalize()\n            &gt;&gt;&gt; magnitudes = jnp.abs(normalized.vec)\n            &gt;&gt;&gt; assert jnp.allclose(magnitudes, 1.0)\n        \"\"\"\n        # Normalize to unit magnitude: z / |z|\n        normalized = self._vec / jnp.abs(self._vec)\n        return ComplexHypervector(normalized)\n\n    @property\n    def phase(self) -&gt; jnp.ndarray:\n        \"\"\"Extract phase component of the complex hypervector.\n\n        Returns:\n            Real-valued array of phase angles in radians, in the range [-\u03c0, \u03c0].\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.exp(1j * jnp.array([0.0, jnp.pi/2, jnp.pi]))\n            &gt;&gt;&gt; hv = ComplexHypervector(vec)\n            &gt;&gt;&gt; phases = hv.phase\n            &gt;&gt;&gt; assert phases.shape == vec.shape\n        \"\"\"\n        return jnp.angle(self._vec)\n\n    @property\n    def magnitude(self) -&gt; jnp.ndarray:\n        \"\"\"Extract magnitude component of the complex hypervector.\n\n        Returns:\n            Real-valued array of magnitudes.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([3+4j, 5+12j])\n            &gt;&gt;&gt; hv = ComplexHypervector(vec)\n            &gt;&gt;&gt; mags = hv.magnitude\n            &gt;&gt;&gt; assert jnp.allclose(mags, jnp.array([5.0, 13.0]))\n        \"\"\"\n        return jnp.abs(self._vec)\n</code></pre>"},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector-attributes","title":"Attributes","text":""},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Extract phase component of the complex hypervector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Real-valued array of phase angles in radians, in the range [-\u03c0, \u03c0].</p> Example <p>import jax.numpy as jnp vec = jnp.exp(1j * jnp.array([0.0, jnp.pi/2, jnp.pi])) hv = ComplexHypervector(vec) phases = hv.phase assert phases.shape == vec.shape</p>"},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector.magnitude","title":"<code>magnitude</code>  <code>property</code>","text":"<p>Extract magnitude component of the complex hypervector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Real-valued array of magnitudes.</p> Example <p>import jax.numpy as jnp vec = jnp.array([3+4j, 5+12j]) hv = ComplexHypervector(vec) mags = hv.magnitude assert jnp.allclose(mags, jnp.array([5.0, 13.0]))</p>"},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector-functions","title":"Functions","text":""},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector.__init__","title":"<code>__init__(vec)</code>","text":"<p>Initialize complex hypervector.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>Complex-valued JAX array.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If vec is not complex-valued.</p> Source code in <code>vsax/representations/complex_hv.py</code> <pre><code>def __init__(self, vec: jnp.ndarray) -&gt; None:\n    \"\"\"Initialize complex hypervector.\n\n    Args:\n        vec: Complex-valued JAX array.\n\n    Raises:\n        TypeError: If vec is not complex-valued.\n    \"\"\"\n    if not jnp.iscomplexobj(vec):\n        raise TypeError(\n            f\"ComplexHypervector requires complex array, got {vec.dtype}\"\n        )\n    super().__init__(vec)\n</code></pre>"},{"location":"api/representations/complex/#vsax.representations.ComplexHypervector.normalize","title":"<code>normalize()</code>","text":"<p>Normalize to unit magnitude (phase-only representation).</p> <p>Returns:</p> Type Description <code>ComplexHypervector</code> <p>New ComplexHypervector with all elements having magnitude 1.0,</p> <code>ComplexHypervector</code> <p>preserving the phase angles.</p> Example <p>import jax.numpy as jnp vec = jnp.array([3+4j, 5+12j]) hv = ComplexHypervector(vec) normalized = hv.normalize() magnitudes = jnp.abs(normalized.vec) assert jnp.allclose(magnitudes, 1.0)</p> Source code in <code>vsax/representations/complex_hv.py</code> <pre><code>def normalize(self) -&gt; \"ComplexHypervector\":\n    \"\"\"Normalize to unit magnitude (phase-only representation).\n\n    Returns:\n        New ComplexHypervector with all elements having magnitude 1.0,\n        preserving the phase angles.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([3+4j, 5+12j])\n        &gt;&gt;&gt; hv = ComplexHypervector(vec)\n        &gt;&gt;&gt; normalized = hv.normalize()\n        &gt;&gt;&gt; magnitudes = jnp.abs(normalized.vec)\n        &gt;&gt;&gt; assert jnp.allclose(magnitudes, 1.0)\n    \"\"\"\n    # Normalize to unit magnitude: z / |z|\n    normalized = self._vec / jnp.abs(self._vec)\n    return ComplexHypervector(normalized)\n</code></pre>"},{"location":"api/representations/real/","title":"RealHypervector","text":"<p>Continuous real-valued hypervector for MAP operations.</p>"},{"location":"api/representations/real/#vsax.representations.RealHypervector","title":"<code>vsax.representations.RealHypervector</code>","text":"<p>               Bases: <code>AbstractHypervector</code></p> <p>Continuous real-valued hypervector for MAP operations.</p> <p>RealHypervector uses real numbers to represent hypervectors. This is commonly used with Multiply-Add-Permute (MAP) operations where element-wise multiplication and averaging are the primary operations.</p> <p>The normalization operation performs L2 normalization, scaling the vector to unit length.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>Real-valued JAX array representing the hypervector.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If vec is complex-valued.</p> Example <p>import jax.numpy as jnp vec = jnp.array([1.0, 2.0, 3.0]) hv = RealHypervector(vec) normalized = hv.normalize() assert jnp.allclose(jnp.linalg.norm(normalized.vec), 1.0)</p> Source code in <code>vsax/representations/real_hv.py</code> <pre><code>class RealHypervector(AbstractHypervector):\n    \"\"\"Continuous real-valued hypervector for MAP operations.\n\n    RealHypervector uses real numbers to represent hypervectors. This is\n    commonly used with Multiply-Add-Permute (MAP) operations where element-wise\n    multiplication and averaging are the primary operations.\n\n    The normalization operation performs L2 normalization, scaling the vector\n    to unit length.\n\n    Args:\n        vec: Real-valued JAX array representing the hypervector.\n\n    Raises:\n        TypeError: If vec is complex-valued.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([1.0, 2.0, 3.0])\n        &gt;&gt;&gt; hv = RealHypervector(vec)\n        &gt;&gt;&gt; normalized = hv.normalize()\n        &gt;&gt;&gt; assert jnp.allclose(jnp.linalg.norm(normalized.vec), 1.0)\n    \"\"\"\n\n    def __init__(self, vec: jnp.ndarray) -&gt; None:\n        \"\"\"Initialize real hypervector.\n\n        Args:\n            vec: Real-valued JAX array.\n\n        Raises:\n            TypeError: If vec is complex-valued.\n        \"\"\"\n        if jnp.iscomplexobj(vec):\n            raise TypeError(\n                f\"RealHypervector requires real array, got complex dtype {vec.dtype}\"\n            )\n        super().__init__(vec)\n\n    def normalize(self) -&gt; \"RealHypervector\":\n        \"\"\"L2 normalization to unit length.\n\n        Returns:\n            New RealHypervector with L2 norm equal to 1.0.\n\n        Example:\n            &gt;&gt;&gt; import jax.numpy as jnp\n            &gt;&gt;&gt; vec = jnp.array([3.0, 4.0])\n            &gt;&gt;&gt; hv = RealHypervector(vec)\n            &gt;&gt;&gt; normalized = hv.normalize()\n            &gt;&gt;&gt; assert jnp.allclose(jnp.linalg.norm(normalized.vec), 1.0)\n            &gt;&gt;&gt; assert jnp.allclose(normalized.vec, jnp.array([0.6, 0.8]))\n        \"\"\"\n        norm = jnp.linalg.norm(self._vec)\n        # Add small epsilon to avoid division by zero\n        normalized = self._vec / (norm + 1e-8)\n        return RealHypervector(normalized)\n</code></pre>"},{"location":"api/representations/real/#vsax.representations.RealHypervector-functions","title":"Functions","text":""},{"location":"api/representations/real/#vsax.representations.RealHypervector.__init__","title":"<code>__init__(vec)</code>","text":"<p>Initialize real hypervector.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>Real-valued JAX array.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If vec is complex-valued.</p> Source code in <code>vsax/representations/real_hv.py</code> <pre><code>def __init__(self, vec: jnp.ndarray) -&gt; None:\n    \"\"\"Initialize real hypervector.\n\n    Args:\n        vec: Real-valued JAX array.\n\n    Raises:\n        TypeError: If vec is complex-valued.\n    \"\"\"\n    if jnp.iscomplexobj(vec):\n        raise TypeError(\n            f\"RealHypervector requires real array, got complex dtype {vec.dtype}\"\n        )\n    super().__init__(vec)\n</code></pre>"},{"location":"api/representations/real/#vsax.representations.RealHypervector.normalize","title":"<code>normalize()</code>","text":"<p>L2 normalization to unit length.</p> <p>Returns:</p> Type Description <code>RealHypervector</code> <p>New RealHypervector with L2 norm equal to 1.0.</p> Example <p>import jax.numpy as jnp vec = jnp.array([3.0, 4.0]) hv = RealHypervector(vec) normalized = hv.normalize() assert jnp.allclose(jnp.linalg.norm(normalized.vec), 1.0) assert jnp.allclose(normalized.vec, jnp.array([0.6, 0.8]))</p> Source code in <code>vsax/representations/real_hv.py</code> <pre><code>def normalize(self) -&gt; \"RealHypervector\":\n    \"\"\"L2 normalization to unit length.\n\n    Returns:\n        New RealHypervector with L2 norm equal to 1.0.\n\n    Example:\n        &gt;&gt;&gt; import jax.numpy as jnp\n        &gt;&gt;&gt; vec = jnp.array([3.0, 4.0])\n        &gt;&gt;&gt; hv = RealHypervector(vec)\n        &gt;&gt;&gt; normalized = hv.normalize()\n        &gt;&gt;&gt; assert jnp.allclose(jnp.linalg.norm(normalized.vec), 1.0)\n        &gt;&gt;&gt; assert jnp.allclose(normalized.vec, jnp.array([0.6, 0.8]))\n    \"\"\"\n    norm = jnp.linalg.norm(self._vec)\n    # Add small epsilon to avoid division by zero\n    normalized = self._vec / (norm + 1e-8)\n    return RealHypervector(normalized)\n</code></pre>"},{"location":"examples/binary/","title":"Binary Model Example","text":"<p>Complete example using Binary VSA with bipolar {-1, +1} hypervectors.</p>"},{"location":"examples/binary/#setup","title":"Setup","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom vsax import VSAModel, BinaryHypervector, BinaryOperations, sample_binary_random\n\n# Create Binary model\nmodel = VSAModel(\n    dim=512,\n    rep_cls=BinaryHypervector,\n    opset=BinaryOperations(),\n    sampler=sample_binary_random\n)\n</code></pre>"},{"location":"examples/binary/#basic-operations","title":"Basic Operations","text":"<pre><code># Sample bipolar vectors\nkey = jax.random.PRNGKey(42)\nvectors = model.sampler(dim=model.dim, n=2, key=key, bipolar=True)\n\na = model.rep_cls(vectors[0], bipolar=True)\nb = model.rep_cls(vectors[1], bipolar=True)\n\n# Verify bipolar values\nprint(f\"Unique values: {jnp.unique(a.vec)}\")  # Array([-1, 1])\n\n# Bind (XOR)\nbound = model.opset.bind(a.vec, b.vec)\n\n# Unbind (exact recovery!)\nrecovered = model.opset.bind(bound, b.vec)\nprint(f\"Exact recovery: {jnp.array_equal(recovered, a.vec)}\")  # True!\n\n# Bundle (majority vote)\nbundled = model.opset.bundle(a.vec, b.vec)\n</code></pre>"},{"location":"examples/binary/#symbolic-reasoning-example","title":"Symbolic Reasoning Example","text":"<p>Encode logical facts using binary vectors.</p> <pre><code># Define symbols\nkeys = jax.random.split(key, 4)\nalice = model.sampler(dim=model.dim, n=1, key=keys[0], bipolar=True)[0]\nbob = model.sampler(dim=model.dim, n=1, key=keys[1], bipolar=True)[0]\nlikes = model.sampler(dim=model.dim, n=1, key=keys[2], bipolar=True)[0]\ncharlie = model.sampler(dim=model.dim, n=1, key=keys[3], bipolar=True)[0]\n\n# Encode: \"Alice likes Bob\"\nfact = model.opset.bind(model.opset.bind(alice, likes), bob)\n\n# Query: Who does Alice like?\nquery = model.opset.bind(fact, model.opset.bind(alice, likes))\n# High Hamming similarity to bob\n</code></pre> <p>Advantage: Binary VSA provides exact unbinding and is hardware-friendly!</p>"},{"location":"examples/fhrr/","title":"FHRR Model Example","text":"<p>Complete example using the FHRR (Fourier Holographic Reduced Representation) model with complex-valued hypervectors.</p>"},{"location":"examples/fhrr/#setup","title":"Setup","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom vsax import VSAModel, ComplexHypervector, FHRROperations, sample_complex_random\n\n# Create FHRR model\nmodel = VSAModel(\n    dim=512,\n    rep_cls=ComplexHypervector,\n    opset=FHRROperations(),\n    sampler=sample_complex_random\n)\n</code></pre>"},{"location":"examples/fhrr/#basic-operations","title":"Basic Operations","text":""},{"location":"examples/fhrr/#sampling-and-normalization","title":"Sampling and Normalization","text":"<pre><code># Sample basis vectors\nkey = jax.random.PRNGKey(42)\nvectors = model.sampler(dim=model.dim, n=3, key=key)\n\n# Create and normalize hypervectors\na = model.rep_cls(vectors[0]).normalize()\nb = model.rep_cls(vectors[1]).normalize()\nc = model.rep_cls(vectors[2]).normalize()\n\n# Verify unit magnitude\nprint(f\"Magnitude of a: {jnp.allclose(jnp.abs(a.vec), 1.0)}\")  # True\n</code></pre>"},{"location":"examples/fhrr/#binding-circular-convolution","title":"Binding (Circular Convolution)","text":"<pre><code># Bind two vectors\nbound = model.opset.bind(a.vec, b.vec)\nbound_hv = model.rep_cls(bound).normalize()\n\nprint(f\"Bound vector shape: {bound_hv.shape}\")\nprint(f\"Is complex: {jnp.iscomplexobj(bound_hv.vec)}\")\n</code></pre>"},{"location":"examples/fhrr/#unbinding-exact-recovery","title":"Unbinding (Exact Recovery)","text":"<pre><code># Unbind to recover original\ninv_b = model.opset.inverse(b.vec)\nrecovered = model.opset.bind(bound_hv.vec, inv_b)\nrecovered_hv = model.rep_cls(recovered).normalize()\n\n# Check similarity (should be very high)\nsimilarity = jnp.abs(jnp.vdot(a.vec, recovered_hv.vec)) / model.dim\nprint(f\"Recovery similarity: {similarity:.4f}\")  # Close to 1.0\n</code></pre>"},{"location":"examples/fhrr/#bundling-superposition","title":"Bundling (Superposition)","text":"<pre><code># Bundle multiple vectors\nbundled = model.opset.bundle(a.vec, b.vec, c.vec)\nbundled_hv = model.rep_cls(bundled)\n\n# Result has unit magnitude\nprint(f\"Bundled magnitude: {jnp.allclose(jnp.abs(bundled_hv.vec), 1.0)}\")  # True\n</code></pre>"},{"location":"examples/fhrr/#role-filler-binding","title":"Role-Filler Binding","text":"<p>Encode structured data using role-filler binding.</p> <pre><code># Define roles and fillers\nkey = jax.random.PRNGKey(42)\nkeys = jax.random.split(key, 6)\n\n# Roles\nsubject_role = model.sampler(dim=model.dim, n=1, key=keys[0])[0]\nverb_role = model.sampler(dim=model.dim, n=1, key=keys[1])[0]\nobject_role = model.sampler(dim=model.dim, n=1, key=keys[2])[0]\n\n# Fillers (concepts)\ndog = model.sampler(dim=model.dim, n=1, key=keys[3])[0]\nchase = model.sampler(dim=model.dim, n=1, key=keys[4])[0]\ncat = model.sampler(dim=model.dim, n=1, key=keys[5])[0]\n\n# Encode sentence: \"The dog chased the cat\"\nsentence = model.opset.bundle(\n    model.opset.bind(subject_role, dog),\n    model.opset.bind(verb_role, chase),\n    model.opset.bind(object_role, cat)\n)\n\n# Query: What is the subject?\nquery = model.opset.bind(sentence, model.opset.inverse(subject_role))\nquery_hv = model.rep_cls(query).normalize()\ndog_hv = model.rep_cls(dog).normalize()\n\n# Similarity to \"dog\" should be high\nsimilarity = jnp.abs(jnp.vdot(query_hv.vec, dog_hv.vec)) / model.dim\nprint(f\"Subject query similarity to 'dog': {similarity:.4f}\")\n</code></pre>"},{"location":"examples/fhrr/#sequence-encoding","title":"Sequence Encoding","text":"<p>Use permutation for positional information.</p> <pre><code># Encode sequence: [A, B, C]\nsequence_keys = jax.random.split(key, 3)\nA = model.sampler(dim=model.dim, n=1, key=sequence_keys[0])[0]\nB = model.sampler(dim=model.dim, n=1, key=sequence_keys[1])[0]\nC = model.sampler(dim=model.dim, n=1, key=sequence_keys[2])[0]\n\n# Encode with positional information\nsequence = model.opset.bundle(\n    A,                              # Position 0\n    model.opset.permute(B, 1),      # Position 1\n    model.opset.permute(C, 2)       # Position 2\n)\n\n# Decode position 1\npos1_query = model.opset.permute(sequence, -1)\n# High similarity to B\n</code></pre>"},{"location":"examples/fhrr/#next-steps","title":"Next Steps","text":"<ul> <li>See MAP Example for real-valued operations</li> <li>See Binary Example for discrete operations</li> <li>Check API Reference for detailed documentation</li> </ul>"},{"location":"examples/map/","title":"MAP Model Example","text":"<p>Complete example using the MAP (Multiply-Add-Permute) model with real-valued hypervectors.</p>"},{"location":"examples/map/#setup","title":"Setup","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom vsax import VSAModel, RealHypervector, MAPOperations, sample_random\n\n# Create MAP model\nmodel = VSAModel(\n    dim=512,\n    rep_cls=RealHypervector,\n    opset=MAPOperations(),\n    sampler=sample_random\n)\n</code></pre>"},{"location":"examples/map/#basic-operations","title":"Basic Operations","text":"<pre><code># Sample and normalize\nkey = jax.random.PRNGKey(42)\nvectors = model.sampler(dim=model.dim, n=2, key=key)\n\na = model.rep_cls(vectors[0]).normalize()\nb = model.rep_cls(vectors[1]).normalize()\n\n# Verify L2 normalization\nprint(f\"L2 norm of a: {jnp.linalg.norm(a.vec):.4f}\")  # 1.0\n\n# Bind (element-wise multiplication)\nbound = model.opset.bind(a.vec, b.vec)\n\n# Bundle (element-wise mean)\nbundled = model.opset.bundle(a.vec, b.vec)\n</code></pre>"},{"location":"examples/map/#feature-binding-example","title":"Feature Binding Example","text":"<p>Encode structured records with real-valued features.</p> <pre><code># Define feature roles\nage_role = model.sampler(dim=model.dim, n=1, key=jax.random.PRNGKey(1))[0]\nincome_role = model.sampler(dim=model.dim, n=1, key=jax.random.PRNGKey(2))[0]\n\n# Encode feature values (simplified - normally you'd use encoders)\nage_25 = model.sampler(dim=model.dim, n=1, key=jax.random.PRNGKey(3))[0]\nincome_50k = model.sampler(dim=model.dim, n=1, key=jax.random.PRNGKey(4))[0]\n\n# Create record\nrecord = model.opset.bundle(\n    model.opset.bind(age_role, age_25),\n    model.opset.bind(income_role, income_50k)\n)\n</code></pre> <p>Note: MAP unbinding is approximate - use for similarity-based retrieval rather than exact recovery.</p>"},{"location":"guide/factory/","title":"Factory Functions: Easy Model Creation","text":"<p>Factory functions provide a simple, one-line way to create VSA models with sensible defaults. Instead of manually configuring representations, operation sets, and samplers, use factory functions for quick setup.</p>"},{"location":"guide/factory/#available-factory-functions","title":"Available Factory Functions","text":"<p>VSAX provides three factory functions, one for each VSA model type:</p> <ul> <li><code>create_fhrr_model()</code> - Complex hypervectors with FFT-based operations</li> <li><code>create_map_model()</code> - Real hypervectors with element-wise operations</li> <li><code>create_binary_model()</code> - Binary hypervectors with XOR/majority operations</li> </ul>"},{"location":"guide/factory/#create_fhrr_model","title":"create_fhrr_model","text":"<p>Create a FHRR (Fourier Holographic Reduced Representation) model.</p> <pre><code>from vsax import create_fhrr_model\n\n# Default dimension (512)\nmodel = create_fhrr_model()\n\n# Custom dimension\nmodel = create_fhrr_model(dim=1024)\n</code></pre> <p>Properties: - Uses <code>ComplexHypervector</code> (complex-valued) - Uses <code>FHRROperations</code> (FFT-based circular convolution) - Uses <code>sample_complex_random</code> (unit magnitude, random phase) - Default dimension: 512 - Unbinding: Exact (via complex conjugate)</p> <p>When to use: - Need exact unbinding - Working with sequential/temporal data - Frequency-domain representations</p>"},{"location":"guide/factory/#create_map_model","title":"create_map_model","text":"<p>Create a MAP (Multiply-Add-Permute) model.</p> <pre><code>from vsax import create_map_model\n\n# Default dimension (512)\nmodel = create_map_model()\n\n# Custom dimension\nmodel = create_map_model(dim=2048)\n</code></pre> <p>Properties: - Uses <code>RealHypervector</code> (real-valued) - Uses <code>MAPOperations</code> (element-wise multiplication/mean) - Uses <code>sample_random</code> (Gaussian distribution) - Default dimension: 512 - Unbinding: Approximate</p> <p>When to use: - Continuous feature representations - Approximate pattern matching - Lower memory footprint than complex</p>"},{"location":"guide/factory/#create_binary_model","title":"create_binary_model","text":"<p>Create a Binary VSA model.</p> <pre><code>from vsax import create_binary_model\n\n# Default dimension (10000), bipolar mode\nmodel = create_binary_model()\n\n# Custom dimension\nmodel = create_binary_model(dim=5000)\n\n# Binary mode {0, 1} instead of bipolar {-1, +1}\nmodel = create_binary_model(dim=10000, bipolar=False)\n</code></pre> <p>Properties: - Uses <code>BinaryHypervector</code> (discrete binary/bipolar) - Uses <code>BinaryOperations</code> (XOR for bind, majority for bundle) - Uses <code>sample_binary_random</code> (random bipolar or binary) - Default dimension: 10000 (higher than continuous models) - Unbinding: Exact (self-inverse property) - Default mode: Bipolar (<code>{-1, +1}</code>)</p> <p>When to use: - Need exact unbinding with minimal computation - Boolean/logical operations - Hardware-friendly representations - Very large symbol spaces (use higher dimensions)</p>"},{"location":"guide/factory/#comparison","title":"Comparison","text":"Model Type Dimension Unbinding Memory Speed FHRR Complex 512 (default) Exact Medium Medium (FFT) MAP Real 512 (default) Approximate Low Fast Binary Discrete 10000 (default) Exact Very Low Very Fast"},{"location":"guide/factory/#complete-example","title":"Complete Example","text":"<pre><code>from vsax import create_fhrr_model, create_map_model, create_binary_model, VSAMemory\nimport jax\n\n# Create all three models\nfhrr = create_fhrr_model(dim=512)\nmap_model = create_map_model(dim=512)\nbinary = create_binary_model(dim=10000, bipolar=True)\n\n# All models work with VSAMemory\nfor model in [fhrr, map_model, binary]:\n    memory = VSAMemory(model, key=jax.random.PRNGKey(42))\n    memory.add_many([\"concept1\", \"concept2\"])\n\n    # Same interface across all models\n    c1 = memory[\"concept1\"]\n    c2 = memory[\"concept2\"]\n\n    # Bind and bundle\n    bound = model.opset.bind(c1.vec, c2.vec)\n    bundled = model.opset.bundle(c1.vec, c2.vec)\n</code></pre>"},{"location":"guide/factory/#versus-manual-creation","title":"Versus Manual Creation","text":"<p>Before (v0.2.0): <pre><code>from vsax import VSAModel, ComplexHypervector, FHRROperations, sample_complex_random\n\nmodel = VSAModel(\n    dim=512,\n    rep_cls=ComplexHypervector,\n    opset=FHRROperations(),\n    sampler=sample_complex_random\n)\n</code></pre></p> <p>After (v0.3.0): <pre><code>from vsax import create_fhrr_model\n\nmodel = create_fhrr_model(dim=512)\n</code></pre></p> <p>Much simpler! Factory functions reduce boilerplate while maintaining full flexibility.</p>"},{"location":"guide/factory/#advanced-custom-models","title":"Advanced: Custom Models","text":"<p>If you need custom configurations, you can still use <code>VSAModel</code> directly:</p> <pre><code>from vsax import VSAModel, RealHypervector, MAPOperations\n\n# Custom sampler\ndef my_sampler(dim, n, key):\n    return jax.random.uniform(key, shape=(n, dim)) * 2 - 1\n\nmodel = VSAModel(\n    dim=256,\n    rep_cls=RealHypervector,\n    opset=MAPOperations(),\n    sampler=my_sampler\n)\n</code></pre> <p>But for 95% of use cases, factory functions are sufficient.</p>"},{"location":"guide/factory/#api-reference","title":"API Reference","text":"<pre><code>def create_fhrr_model(dim: int = 512, key: Optional[jax.Array] = None) -&gt; VSAModel:\n    \"\"\"Create FHRR model with complex hypervectors.\"\"\"\n\ndef create_map_model(dim: int = 512, key: Optional[jax.Array] = None) -&gt; VSAModel:\n    \"\"\"Create MAP model with real hypervectors.\"\"\"\n\ndef create_binary_model(\n    dim: int = 10000,\n    bipolar: bool = True,\n    key: Optional[jax.Array] = None\n) -&gt; VSAModel:\n    \"\"\"Create Binary model with discrete hypervectors.\"\"\"\n</code></pre>"},{"location":"guide/factory/#next-steps","title":"Next Steps","text":"<ul> <li>VSAMemory Guide - Symbol table management</li> <li>Operations Guide - Binding and bundling</li> <li>Examples - Complete working examples</li> </ul>"},{"location":"guide/memory/","title":"VSAMemory: Symbol Table Management","text":"<p>VSAMemory provides a dictionary-style interface for creating and managing named hypervectors (basis symbols). It acts as a symbol table that automatically samples and stores hypervectors for symbolic concepts.</p>"},{"location":"guide/memory/#overview","title":"Overview","text":"<p>VSAMemory simplifies working with VSA models by:</p> <ul> <li>Automatic sampling: Creates hypervectors on-demand when you add symbols</li> <li>Dictionary-style access: Use familiar <code>memory[\"symbol\"]</code> syntax</li> <li>Reproducibility: Optional PRNG key for deterministic sampling</li> <li>Model-agnostic: Works with FHRR, MAP, and Binary models</li> </ul>"},{"location":"guide/memory/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/memory/#creating-memory","title":"Creating Memory","text":"<pre><code>from vsax import create_fhrr_model, VSAMemory\n\n# Create a model\nmodel = create_fhrr_model(dim=512)\n\n# Create memory (with optional key for reproducibility)\nmemory = VSAMemory(model, key=jax.random.PRNGKey(42))\n</code></pre>"},{"location":"guide/memory/#adding-symbols","title":"Adding Symbols","text":"<pre><code># Add a single symbol\ndog = memory.add(\"dog\")\n\n# Add multiple symbols\nmemory.add_many([\"cat\", \"bird\", \"fish\"])\n\n# Adding duplicate returns the same hypervector\ndog2 = memory.add(\"dog\")  # Same as dog\nassert jnp.array_equal(dog.vec, dog2.vec)\n</code></pre>"},{"location":"guide/memory/#accessing-symbols","title":"Accessing Symbols","text":"<pre><code># Dictionary-style access\ndog = memory[\"dog\"]\ncat = memory[\"cat\"]\n\n# Check if symbol exists\nif \"dog\" in memory:\n    print(\"Dog is in memory\")\n\n# Get all symbol names\nsymbols = memory.keys()  # ['dog', 'cat', 'bird', 'fish']\n\n# Number of symbols\ncount = len(memory)  # 4\n</code></pre>"},{"location":"guide/memory/#using-symbols","title":"Using Symbols","text":"<pre><code># Get the underlying vector\ndog_vec = memory[\"dog\"].vec\n\n# Bind two concepts\ndog_is_animal = model.opset.bind(memory[\"dog\"].vec, memory[\"animal\"].vec)\n\n# Bundle multiple concepts\npets = model.opset.bundle(\n    memory[\"dog\"].vec,\n    memory[\"cat\"].vec,\n    memory[\"bird\"].vec\n)\n</code></pre>"},{"location":"guide/memory/#clearing-memory","title":"Clearing Memory","text":"<pre><code># Remove all symbols\nmemory.clear()\nassert len(memory) == 0\n</code></pre>"},{"location":"guide/memory/#complete-example-role-filler-binding","title":"Complete Example: Role-Filler Binding","text":"<pre><code>import jax\nfrom vsax import create_fhrr_model, VSAMemory\n\n# Create FHRR model and memory\nmodel = create_fhrr_model(dim=512)\nmemory = VSAMemory(model, key=jax.random.PRNGKey(42))\n\n# Add roles and fillers\nmemory.add_many([\"subject\", \"predicate\", \"object\"])\nmemory.add_many([\"dog\", \"chases\", \"cat\"])\n\n# Create sentence: \"dog chases cat\"\nsubject_dog = model.opset.bind(\n    memory[\"subject\"].vec,\n    memory[\"dog\"].vec\n)\n\npredicate_chases = model.opset.bind(\n    memory[\"predicate\"].vec,\n    memory[\"chases\"].vec\n)\n\nobject_cat = model.opset.bind(\n    memory[\"object\"].vec,\n    memory[\"cat\"].vec\n)\n\n# Bundle into sentence representation\nsentence = model.opset.bundle(subject_dog, predicate_chases, object_cat)\n</code></pre>"},{"location":"guide/memory/#reproducibility","title":"Reproducibility","text":"<p>Use a PRNG key for deterministic symbol generation:</p> <pre><code>import jax\n\nkey = jax.random.PRNGKey(42)\n\n# Two memories with same key produce identical symbols\nmemory1 = VSAMemory(create_fhrr_model(dim=512), key=key)\nmemory2 = VSAMemory(create_fhrr_model(dim=512), key=key)\n\ndog1 = memory1.add(\"dog\")\ndog2 = memory2.add(\"dog\")\n\nassert jnp.array_equal(dog1.vec, dog2.vec)  # Identical\n</code></pre>"},{"location":"guide/memory/#working-with-different-models","title":"Working with Different Models","text":"<p>VSAMemory works identically across all model types:</p>"},{"location":"guide/memory/#fhrr-model","title":"FHRR Model","text":"<pre><code>fhrr = create_fhrr_model(dim=512)\nmemory = VSAMemory(fhrr)\ndog = memory.add(\"dog\")\n# dog.vec is complex-valued\n</code></pre>"},{"location":"guide/memory/#map-model","title":"MAP Model","text":"<pre><code>map_model = create_map_model(dim=512)\nmemory = VSAMemory(map_model)\nfeature = memory.add(\"feature\")\n# feature.vec is real-valued\n</code></pre>"},{"location":"guide/memory/#binary-model","title":"Binary Model","text":"<pre><code>binary = create_binary_model(dim=10000, bipolar=True)\nmemory = VSAMemory(binary)\nconcept = memory.add(\"concept\")\n# concept.vec is bipolar {-1, +1}\n</code></pre>"},{"location":"guide/memory/#api-reference","title":"API Reference","text":""},{"location":"guide/memory/#vsamemory-class","title":"VSAMemory Class","text":"<pre><code>class VSAMemory:\n    def __init__(self, model: VSAModel, key: Optional[jax.Array] = None):\n        \"\"\"Initialize VSAMemory with a model.\"\"\"\n\n    def add(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Add a symbol and return its hypervector.\"\"\"\n\n    def add_many(self, names: Iterable[str]) -&gt; List[AbstractHypervector]:\n        \"\"\"Add multiple symbols at once.\"\"\"\n\n    def get(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Get a hypervector by name (raises KeyError if missing).\"\"\"\n\n    def __getitem__(self, name: str) -&gt; AbstractHypervector:\n        \"\"\"Dictionary-style access: memory[\"dog\"]\"\"\"\n\n    def __contains__(self, name: str) -&gt; bool:\n        \"\"\"Check if symbol exists: \"dog\" in memory\"\"\"\n\n    def keys(self) -&gt; List[str]:\n        \"\"\"Get all symbol names.\"\"\"\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all symbols.\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of stored symbols.\"\"\"\n</code></pre>"},{"location":"guide/memory/#best-practices","title":"Best Practices","text":"<ol> <li>Use factory functions: Create models with <code>create_fhrr_model()</code>, <code>create_map_model()</code>, or <code>create_binary_model()</code></li> <li>Add symbols upfront: Add all symbols at once with <code>add_many()</code> for consistency</li> <li>Use keys for reproducibility: Pass a PRNG key when reproducibility matters</li> <li>Access vectors explicitly: Use <code>.vec</code> to get the underlying array for operations</li> </ol>"},{"location":"guide/memory/#next-steps","title":"Next Steps","text":"<ul> <li>Factory Functions - Easy model creation</li> <li>Operations Guide - Binding and bundling operations</li> <li>Examples - Complete working examples</li> </ul>"},{"location":"guide/models/","title":"VSA Models","text":"<p>The <code>VSAModel</code> is an immutable container that defines a complete VSA algebra by combining a representation type, operation set, and sampler.</p>"},{"location":"guide/models/#vsamodel-structure","title":"VSAModel Structure","text":"<pre><code>@dataclass(frozen=True)\nclass VSAModel:\n    dim: int                          # Dimensionality\n    rep_cls: type[AbstractHypervector]  # Representation class\n    opset: AbstractOpSet              # Operation set\n    sampler: Callable                 # Sampling function\n</code></pre>"},{"location":"guide/models/#creating-models","title":"Creating Models","text":""},{"location":"guide/models/#fhrr-model","title":"FHRR Model","text":"<pre><code>from vsax import VSAModel, ComplexHypervector, FHRROperations, sample_complex_random\n\nfhrr_model = VSAModel(\n    dim=512,\n    rep_cls=ComplexHypervector,\n    opset=FHRROperations(),\n    sampler=sample_complex_random\n)\n</code></pre>"},{"location":"guide/models/#map-model","title":"MAP Model","text":"<pre><code>from vsax import RealHypervector, MAPOperations, sample_random\n\nmap_model = VSAModel(\n    dim=512,\n    rep_cls=RealHypervector,\n    opset=MAPOperations(),\n    sampler=sample_random\n)\n</code></pre>"},{"location":"guide/models/#binary-model","title":"Binary Model","text":"<pre><code>from vsax import BinaryHypervector, BinaryOperations, sample_binary_random\n\nbinary_model = VSAModel(\n    dim=512,\n    rep_cls=BinaryHypervector,\n    opset=BinaryOperations(),\n    sampler=sample_binary_random\n)\n</code></pre>"},{"location":"guide/models/#using-models","title":"Using Models","text":"<pre><code>import jax\n\n# Sample basis vectors\nkey = jax.random.PRNGKey(42)\nvectors = fhrr_model.sampler(dim=fhrr_model.dim, n=2, key=key)\n\n# Create hypervectors using model's representation\na = fhrr_model.rep_cls(vectors[0]).normalize()\nb = fhrr_model.rep_cls(vectors[1]).normalize()\n\n# Perform operations using model's opset\nbound = fhrr_model.opset.bind(a.vec, b.vec)\nbundled = fhrr_model.opset.bundle(a.vec, b.vec)\n</code></pre>"},{"location":"guide/models/#model-properties","title":"Model Properties","text":"<p>Immutability: Models are frozen dataclasses - cannot be modified after creation.</p> <pre><code>model = VSAModel(dim=512, ...)\n\n# This will raise an error\nmodel.dim = 1024  # FrozenInstanceError!\n</code></pre> <p>Type Safety: The model ensures all components work together correctly.</p>"},{"location":"guide/models/#next-vsamemory-coming-in-iteration-3","title":"Next: VSAMemory (Coming in Iteration 3)","text":"<p>In the next iteration, you'll be able to use <code>VSAMemory</code> to manage named basis vectors:</p> <pre><code># Coming soon!\nmemory = VSAMemory(model)\nmemory.add(\"dog\")\nmemory.add(\"cat\")\n\ndog = memory[\"dog\"]  # Access by name\n</code></pre>"},{"location":"guide/models/#next-steps","title":"Next Steps","text":"<ul> <li>See Examples for complete model usage</li> <li>Check API Reference for detailed documentation</li> </ul>"},{"location":"guide/operations/","title":"VSA Operations","text":"<p>VSA operations define how hypervectors are combined and manipulated. VSAX provides three operation sets, each corresponding to a representation type.</p>"},{"location":"guide/operations/#overview","title":"Overview","text":"<p>All operation sets implement the <code>AbstractOpSet</code> interface with four core operations:</p> Operation Purpose Example <code>bind(a, b)</code> Combine/associate two vectors Role-filler binding <code>bundle(*vecs)</code> Superposition of multiple vectors Create composite representations <code>inverse(a)</code> Compute inverse for unbinding Retrieve bound information <code>permute(a, shift)</code> Circular shift/rotation Sequential encoding"},{"location":"guide/operations/#fhrroperations","title":"FHRROperations","text":"<p>Operations for complex-valued hypervectors using FFT-based circular convolution.</p>"},{"location":"guide/operations/#binding-circular-convolution","title":"Binding (Circular Convolution)","text":"<p>Binds two complex vectors using circular convolution implemented via FFT.</p> <pre><code>from vsax import FHRROperations\nimport jax.numpy as jnp\n\nops = FHRROperations()\n\n# Create unit-magnitude complex vectors\na = jnp.exp(1j * jnp.array([0.1, 0.5, 1.0, 1.5]))\nb = jnp.exp(1j * jnp.array([0.2, 0.6, 1.1, 1.6]))\n\n# Bind via circular convolution\nbound = ops.bind(a, b)\n\n# Result is also complex\nassert jnp.iscomplexobj(bound)\n</code></pre> <p>Properties: - Commutative: <code>bind(a, b) = bind(b, a)</code> - Associative: <code>bind(a, bind(b, c)) = bind(bind(a, b), c)</code> - Invertible: Can recover <code>a</code> from <code>bind(a, b)</code> using <code>inverse(b)</code></p>"},{"location":"guide/operations/#bundling-sum-and-normalize","title":"Bundling (Sum and Normalize)","text":"<p>Bundles multiple vectors by summing and normalizing to unit magnitude.</p> <pre><code># Bundle three vectors\nbundled = ops.bundle(a, b, c)\n\n# All elements have unit magnitude\nassert jnp.allclose(jnp.abs(bundled), 1.0)\n</code></pre> <p>Properties: - Similarity preserving: Bundled vector is similar to constituents - Approximate: Some information loss occurs - Commutative: Order doesn't matter</p>"},{"location":"guide/operations/#inverse-complex-conjugate","title":"Inverse (Complex Conjugate)","text":"<p>For complex vectors, the inverse is the complex conjugate.</p> <pre><code># Unbind to recover original\ninv_b = ops.inverse(b)\nrecovered = ops.bind(bound, inv_b)\n\n# recovered \u2248 a (with high similarity)\n</code></pre>"},{"location":"guide/operations/#example-role-filler-binding","title":"Example: Role-Filler Binding","text":"<pre><code># Represent \"The dog chased the cat\"\nsubject = jnp.exp(1j * jax.random.uniform(key1, (512,)))\nverb = jnp.exp(1j * jax.random.uniform(key2, (512,)))\nobject_ = jnp.exp(1j * jax.random.uniform(key3, (512,)))\n\ndog = jnp.exp(1j * jax.random.uniform(key4, (512,)))\nchase = jnp.exp(1j * jax.random.uniform(key5, (512,)))\ncat = jnp.exp(1j * jax.random.uniform(key6, (512,)))\n\n# Create sentence representation\nsentence = ops.bundle(\n    ops.bind(subject, dog),\n    ops.bind(verb, chase),\n    ops.bind(object_, cat)\n)\n\n# Query: What was the subject?\nquery = ops.bind(sentence, ops.inverse(subject))\n# query \u2248 dog (high similarity)\n</code></pre>"},{"location":"guide/operations/#mapoperations","title":"MAPOperations","text":"<p>Operations for real-valued hypervectors using element-wise operations.</p>"},{"location":"guide/operations/#binding-element-wise-multiplication","title":"Binding (Element-wise Multiplication)","text":"<p>Simplest binding operation - just multiply element-wise.</p> <pre><code>from vsax import MAPOperations\n\nops = MAPOperations()\n\n# Real vectors\na = jax.random.normal(key1, (512,))\nb = jax.random.normal(key2, (512,))\n\n# Bind via multiplication\nbound = ops.bind(a, b)\nassert bound.shape == a.shape\nassert jnp.array_equal(bound, a * b)\n</code></pre> <p>Properties: - Commutative: <code>bind(a, b) = bind(b, a)</code> - Associative: <code>bind(a, bind(b, c)) = bind(bind(a, b), c)</code> - Approximate unbinding: Cannot perfectly recover original</p>"},{"location":"guide/operations/#bundling-element-wise-mean","title":"Bundling (Element-wise Mean)","text":"<p>Average of all input vectors.</p> <pre><code># Bundle three vectors\nbundled = ops.bundle(a, b, c)\n\n# Result is the mean\nassert jnp.allclose(bundled, (a + b + c) / 3)\n</code></pre> <p>Properties: - Order-independent - Lossy: Individual vectors cannot be perfectly recovered - Preserves similarity: Bundled vector similar to constituents</p>"},{"location":"guide/operations/#inverse-approximate","title":"Inverse (Approximate)","text":"<p>MAP uses an approximate inverse based on normalization.</p> <pre><code># Approximate inverse\ninv_b = ops.inverse(b)\n\n# Unbinding is approximate\nrecovered = ops.bind(bound, inv_b)\n# recovered \u2248 a (but not exact)\n</code></pre> <p>Note: MAP unbinding is approximate - use for applications where exact recovery isn't critical.</p>"},{"location":"guide/operations/#example-feature-binding","title":"Example: Feature Binding","text":"<pre><code># Represent a data point: {age: 25, income: 50000, city: \"SF\"}\nage_role = jax.random.normal(key1, (512,))\nincome_role = jax.random.normal(key2, (512,))\ncity_role = jax.random.normal(key3, (512,))\n\nage_25 = jax.random.normal(key4, (512,))\nincome_50k = jax.random.normal(key5, (512,))\nsf = jax.random.normal(key6, (512,))\n\n# Create record\nrecord = ops.bundle(\n    ops.bind(age_role, age_25),\n    ops.bind(income_role, income_50k),\n    ops.bind(city_role, sf)\n)\n</code></pre>"},{"location":"guide/operations/#binaryoperations","title":"BinaryOperations","text":"<p>Operations for binary hypervectors using XOR and majority voting.</p>"},{"location":"guide/operations/#binding-xor","title":"Binding (XOR)","text":"<p>In bipolar {-1, +1} representation, XOR is implemented as multiplication.</p> <pre><code>from vsax import BinaryOperations\n\nops = BinaryOperations()\n\n# Bipolar vectors\na = jnp.array([1, -1, 1, -1, 1, 1, -1, -1])\nb = jnp.array([1, 1, -1, -1, 1, -1, 1, -1])\n\n# Bind via XOR (multiplication in bipolar)\nbound = ops.bind(a, b)\n\n# Result: element-wise multiplication\n# Same values \u2192 +1, different values \u2192 -1\n</code></pre> <p>Properties: - Commutative: <code>bind(a, b) = bind(b, a)</code> - Associative: <code>bind(a, bind(b, c)) = bind(bind(a, b), c)</code> - Self-inverse: <code>bind(bind(a, b), b) = a</code> (exact unbinding!)</p>"},{"location":"guide/operations/#bundling-majority-vote","title":"Bundling (Majority Vote)","text":"<p>Each position in the bundled vector is determined by majority vote.</p> <pre><code>a = jnp.array([1, -1, 1, -1])\nb = jnp.array([1, 1, -1, -1])\nc = jnp.array([1, 1, 1, 1])\n\nbundled = ops.bundle(a, b, c)\n\n# Position 0: [1, 1, 1] \u2192 majority 1\n# Position 1: [-1, 1, 1] \u2192 majority 1\n# Position 2: [1, -1, 1] \u2192 majority 1\n# Position 3: [-1, -1, 1] \u2192 majority -1\n# Result: [1, 1, 1, -1]\n</code></pre> <p>Tie Breaking: For even numbers of vectors, ties default to +1.</p>"},{"location":"guide/operations/#inverse-self-inverse","title":"Inverse (Self-Inverse)","text":"<p>XOR is its own inverse, so <code>inverse(a) = a</code>.</p> <pre><code># Exact unbinding\ninv_b = ops.inverse(b)  # inv_b == b\nrecovered = ops.bind(bound, inv_b)\nassert jnp.array_equal(recovered, a)  # Exact recovery!\n</code></pre>"},{"location":"guide/operations/#example-symbolic-reasoning","title":"Example: Symbolic Reasoning","text":"<pre><code># Encode facts: \"Alice likes Bob\", \"Bob likes Charlie\"\nalice = jax.random.choice(key1, jnp.array([-1, 1]), (512,))\nbob = jax.random.choice(key2, jnp.array([-1, 1]), (512,))\ncharlie = jax.random.choice(key3, jnp.array([-1, 1]), (512,))\nlikes = jax.random.choice(key4, jnp.array([-1, 1]), (512,))\n\n# Create knowledge base\nfact1 = ops.bind(ops.bind(alice, likes), bob)\nfact2 = ops.bind(ops.bind(bob, likes), charlie)\nkb = ops.bundle(fact1, fact2)\n\n# Query: Who does Alice like?\nquery = ops.bind(ops.bind(kb, alice), likes)\n# High similarity to bob\n</code></pre>"},{"location":"guide/operations/#permutation","title":"Permutation","text":"<p>All operation sets support circular permutation (rotation).</p> <pre><code>vec = jnp.array([1, 2, 3, 4, 5])\n\n# Rotate right by 2\nshifted = ops.permute(vec, 2)\n# Result: [4, 5, 1, 2, 3]\n\n# Rotate left by 2\nshifted = ops.permute(vec, -2)\n# Result: [3, 4, 5, 1, 2]\n</code></pre> <p>Use cases: - Sequence encoding - Temporal ordering - Positional information</p>"},{"location":"guide/operations/#comparison","title":"Comparison","text":"Feature FHRR MAP Binary Binding FFT convolution Element-wise \u00d7 XOR Unbinding Exact (conjugate) Approximate Exact (self-inverse) Bundling Sum + normalize Mean Majority vote Complexity O(n log n) O(n) O(n) Memory 2x (complex) 1x 1/32x"},{"location":"guide/operations/#best-practices","title":"Best Practices","text":"<ol> <li>Normalize inputs: Ensure vectors are properly normalized before operations</li> <li>Consistent types: Don't mix operation sets with wrong representations</li> <li>Batch operations: Use JAX's <code>vmap</code> for processing multiple vectors</li> <li>Numerical stability: Be aware of numerical precision, especially with FHRR</li> </ol>"},{"location":"guide/operations/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Sampling to create basis vectors</li> <li>See Models to combine representations and operations</li> <li>Check Examples for complete workflows</li> </ul>"},{"location":"guide/representations/","title":"Hypervector Representations","text":"<p>VSAX provides three hypervector representations, each designed for a specific VSA algebra. All representations inherit from <code>AbstractHypervector</code> and provide a consistent interface.</p>"},{"location":"guide/representations/#overview","title":"Overview","text":"Representation Values Use Case Operations <code>ComplexHypervector</code> Complex unit-magnitude FHRR (Fourier) Circular convolution <code>RealHypervector</code> Real continuous MAP Element-wise multiply <code>BinaryHypervector</code> Bipolar {-1,+1} or Binary {0,1} Binary VSA XOR, majority vote"},{"location":"guide/representations/#complexhypervector","title":"ComplexHypervector","text":"<p>Phase-based representation using complex numbers for FHRR (Fourier Holographic Reduced Representation).</p>"},{"location":"guide/representations/#features","title":"Features","text":"<ul> <li>Unit magnitude: All elements have magnitude 1.0</li> <li>Phase encoding: Information stored in phase (angle)</li> <li>Exact unbinding: Circular convolution is invertible via conjugate</li> <li>GPU-friendly: Leverages JAX's complex number support</li> </ul>"},{"location":"guide/representations/#example","title":"Example","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom vsax import ComplexHypervector, sample_complex_random\n\n# Sample a complex vector\nkey = jax.random.PRNGKey(42)\nvec = sample_complex_random(dim=512, n=1, key=key)[0]\n\n# Create hypervector\nhv = ComplexHypervector(vec)\n\n# Normalize to unit magnitude (phase-only)\nnormalized = hv.normalize()\n\n# Access properties\nprint(f\"Phase: {hv.phase}\")           # Angles in [-\u03c0, \u03c0]\nprint(f\"Magnitude: {hv.magnitude}\")    # All should be ~1.0\nprint(f\"Shape: {hv.shape}\")            # (512,)\n</code></pre>"},{"location":"guide/representations/#properties","title":"Properties","text":"<ul> <li><code>phase</code>: Extract phase component (angles)</li> <li><code>magnitude</code>: Extract magnitude component</li> <li><code>vec</code>: Underlying JAX array</li> <li><code>shape</code>: Vector shape</li> <li><code>dtype</code>: Data type (complex64 or complex128)</li> </ul>"},{"location":"guide/representations/#methods","title":"Methods","text":"<ul> <li><code>normalize()</code>: Normalize to unit magnitude (phase-only representation)</li> <li><code>to_numpy()</code>: Convert to NumPy array</li> </ul>"},{"location":"guide/representations/#realhypervector","title":"RealHypervector","text":"<p>Continuous real-valued representation for MAP (Multiply-Add-Permute) operations.</p>"},{"location":"guide/representations/#features_1","title":"Features","text":"<ul> <li>L2 normalization: Vectors normalized to unit length</li> <li>Continuous values: Real-valued elements</li> <li>Approximate unbinding: MAP unbinding is approximate, not exact</li> <li>Simple operations: Element-wise multiplication and mean</li> </ul>"},{"location":"guide/representations/#example_1","title":"Example","text":"<pre><code>from vsax import RealHypervector, sample_random\n\n# Sample a real vector\nkey = jax.random.PRNGKey(42)\nvec = sample_random(dim=512, n=1, key=key)[0]\n\n# Create hypervector\nhv = RealHypervector(vec)\n\n# L2 normalize\nnormalized = hv.normalize()\n\n# Properties\nprint(f\"L2 norm: {jnp.linalg.norm(normalized.vec)}\")  # Should be 1.0\nprint(f\"Is complex: {jnp.iscomplexobj(hv.vec)}\")      # False\n</code></pre>"},{"location":"guide/representations/#methods_1","title":"Methods","text":"<ul> <li><code>normalize()</code>: L2 normalization to unit length</li> <li><code>to_numpy()</code>: Convert to NumPy array</li> </ul>"},{"location":"guide/representations/#binaryhypervector","title":"BinaryHypervector","text":"<p>Discrete binary representation for Binary VSA with XOR binding.</p>"},{"location":"guide/representations/#features_2","title":"Features","text":"<ul> <li>Exact unbinding: XOR is self-inverse</li> <li>Two modes: Bipolar {-1, +1} or Binary {0, 1}</li> <li>Hardware-friendly: Efficient for digital hardware</li> <li>Majority voting: Robust bundling via majority vote</li> </ul>"},{"location":"guide/representations/#example_2","title":"Example","text":"<pre><code>from vsax import BinaryHypervector, sample_binary_random\n\n# Sample bipolar vectors\nkey = jax.random.PRNGKey(42)\nvec = sample_binary_random(dim=512, n=1, key=key, bipolar=True)[0]\n\n# Create bipolar hypervector\nhv = BinaryHypervector(vec, bipolar=True)\n\n# Check mode\nprint(f\"Is bipolar: {hv.bipolar}\")  # True\n\n# Convert between representations\nbinary_hv = hv.to_binary()      # Convert to {0, 1}\nbipolar_hv = binary_hv.to_bipolar()  # Convert back to {-1, +1}\n\n# Verify values\nprint(f\"Values: {jnp.unique(hv.vec)}\")  # Array([-1, 1])\n</code></pre>"},{"location":"guide/representations/#conversion","title":"Conversion","text":"<pre><code># Bipolar {-1, +1} to Binary {0, 1}\n# Formula: (x + 1) / 2\n# Example: -1 \u2192 0, +1 \u2192 1\n\n# Binary {0, 1} to Bipolar {-1, +1}\n# Formula: 2*x - 1\n# Example: 0 \u2192 -1, 1 \u2192 +1\n</code></pre>"},{"location":"guide/representations/#properties_1","title":"Properties","text":"<ul> <li><code>bipolar</code>: Check if using bipolar encoding</li> <li><code>vec</code>: Underlying JAX array</li> <li><code>shape</code>: Vector shape</li> <li><code>dtype</code>: Data type (typically int32)</li> </ul>"},{"location":"guide/representations/#methods_2","title":"Methods","text":"<ul> <li><code>normalize()</code>: No-op for binary (already normalized)</li> <li><code>to_bipolar()</code>: Convert to {-1, +1} representation</li> <li><code>to_binary()</code>: Convert to {0, 1} representation</li> <li><code>to_numpy()</code>: Convert to NumPy array</li> </ul>"},{"location":"guide/representations/#common-interface","title":"Common Interface","text":"<p>All representations share a common interface via <code>AbstractHypervector</code>:</p> <pre><code>class AbstractHypervector:\n    @property\n    def vec(self) -&gt; jnp.ndarray:\n        \"\"\"Access underlying JAX array\"\"\"\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Vector shape\"\"\"\n\n    @property\n    def dtype(self):\n        \"\"\"Data type\"\"\"\n\n    def normalize(self) -&gt; \"AbstractHypervector\":\n        \"\"\"Normalize the hypervector\"\"\"\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"Convert to NumPy array\"\"\"\n</code></pre>"},{"location":"guide/representations/#choosing-a-representation","title":"Choosing a Representation","text":"<p>Use ComplexHypervector when: - You need exact unbinding - Working with sequences or structured data - GPU acceleration is available - Circular convolution is suitable for your task</p> <p>Use RealHypervector when: - You have continuous-valued data - Approximate unbinding is acceptable - Simple operations are preferred - Working with embeddings or features</p> <p>Use BinaryHypervector when: - Deploying to hardware (FPGA, ASIC) - Memory constraints are tight - You need exact unbinding - Working with symbolic/discrete data</p>"},{"location":"guide/representations/#performance-considerations","title":"Performance Considerations","text":"Representation Memory Computation Unbinding Complex 2x (real+imag) FFT overhead Exact Real 1x Fast multiply/add Approximate Binary 1/32x (int vs float) Fastest Exact"},{"location":"guide/representations/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Operations for each representation</li> <li>See Examples for complete workflows</li> <li>Check API Reference for detailed docs</li> </ul>"},{"location":"guide/sampling/","title":"Sampling Hypervectors","text":"<p>VSAX provides sampling functions to generate random basis hypervectors for each representation type.</p>"},{"location":"guide/sampling/#overview","title":"Overview","text":"Function Output Distribution Use With <code>sample_random</code> Real vectors Normal N(0,1) RealHypervector, MAP <code>sample_complex_random</code> Complex vectors Uniform phase ComplexHypervector, FHRR <code>sample_binary_random</code> Binary vectors Uniform {-1,+1} or {0,1} BinaryHypervector, Binary"},{"location":"guide/sampling/#sample_random","title":"sample_random","text":"<p>Samples real-valued vectors from standard normal distribution.</p> <pre><code>from vsax.sampling import sample_random\nimport jax\n\nkey = jax.random.PRNGKey(42)\nvectors = sample_random(dim=512, n=10, key=key)\n\n# Shape: (10, 512)\n# Elements: drawn from N(0, 1)\n</code></pre> <p>Parameters: - <code>dim</code>: Vector dimensionality - <code>n</code>: Number of vectors to sample - <code>key</code>: JAX random key (optional, defaults to PRNGKey(0))</p>"},{"location":"guide/sampling/#sample_complex_random","title":"sample_complex_random","text":"<p>Samples unit-magnitude complex vectors with uniformly random phases.</p> <pre><code>from vsax.sampling import sample_complex_random\n\nkey = jax.random.PRNGKey(42)\nvectors = sample_complex_random(dim=512, n=10, key=key)\n\n# All magnitudes are 1.0\nassert jnp.allclose(jnp.abs(vectors), 1.0)\n\n# Phases uniformly distributed in [0, 2\u03c0)\nphases = jnp.angle(vectors)\n</code></pre> <p>Properties: - All elements have magnitude 1.0 - Phases uniformly distributed in [0, 2\u03c0) - Suitable for FHRR operations</p>"},{"location":"guide/sampling/#sample_binary_random","title":"sample_binary_random","text":"<p>Samples binary vectors with values from {-1, +1} (bipolar) or {0, 1} (binary).</p> <pre><code>from vsax.sampling import sample_binary_random\n\nkey = jax.random.PRNGKey(42)\n\n# Bipolar sampling (default)\nbipolar_vecs = sample_binary_random(dim=512, n=10, key=key, bipolar=True)\nassert jnp.all(jnp.isin(bipolar_vecs, jnp.array([-1, 1])))\n\n# Binary sampling\nbinary_vecs = sample_binary_random(dim=512, n=10, key=key, bipolar=False)\nassert jnp.all(jnp.isin(binary_vecs, jnp.array([0, 1])))\n</code></pre> <p>Parameters: - <code>dim</code>: Vector dimensionality - <code>n</code>: Number of vectors to sample - <code>key</code>: JAX random key (optional) - <code>bipolar</code>: If True, sample from {-1, +1}; if False, sample from {0, 1}</p>"},{"location":"guide/sampling/#reproducibility","title":"Reproducibility","text":"<p>Use JAX's PRNG system for reproducible sampling:</p> <pre><code># Same key = same samples\nkey = jax.random.PRNGKey(42)\nsamples1 = sample_random(dim=100, n=5, key=key)\nsamples2 = sample_random(dim=100, n=5, key=key)\nassert jnp.array_equal(samples1, samples2)\n\n# Different keys = different samples\nkey2 = jax.random.PRNGKey(43)\nsamples3 = sample_random(dim=100, n=5, key=key2)\nassert not jnp.array_equal(samples1, samples3)\n</code></pre>"},{"location":"guide/sampling/#complete-example","title":"Complete Example","text":"<pre><code>import jax\nfrom vsax import VSAModel, ComplexHypervector, FHRROperations, sample_complex_random\n\n# Create model with sampler\nmodel = VSAModel(\n    dim=512,\n    rep_cls=ComplexHypervector,\n    opset=FHRROperations(),\n    sampler=sample_complex_random\n)\n\n# Use model's sampler\nkey = jax.random.PRNGKey(42)\nbasis_vectors = model.sampler(dim=model.dim, n=100, key=key)\n\n# Create hypervectors\nhvs = [model.rep_cls(vec).normalize() for vec in basis_vectors]\n</code></pre>"},{"location":"guide/sampling/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Models to combine samplers with representations</li> <li>See Examples for complete workflows</li> </ul>"}]}